var libde265WorkerBlob=`var Module = typeof Module !== "undefined" ? Module : {};\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n    if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key]\n    }\n}\nModule["arguments"] = [];\nModule["thisProgram"] = "./this.program";\nModule["quit"] = (function (status, toThrow) {\n    throw toThrow\n});\nModule["preRun"] = [];\nModule["postRun"] = [];\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === "object";\nENVIRONMENT_IS_WORKER = typeof importScripts === "function";\nENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\nvar scriptDirectory = "";\n\nfunction locateFile(path) {\n    if (Module["locateFile"]) {\n        return Module["locateFile"](path, scriptDirectory)\n    } else {\n        return scriptDirectory + path\n    }\n}\nif (ENVIRONMENT_IS_NODE) {\n    scriptDirectory = __dirname + "/";\n    var nodeFS;\n    var nodePath;\n    Module["read"] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = require("fs");\n        if (!nodePath) nodePath = require("path");\n        filename = nodePath["normalize"](filename);\n        ret = nodeFS["readFileSync"](filename);\n        return binary ? ret : ret.toString()\n    };\n    Module["readBinary"] = function readBinary(filename) {\n        var ret = Module["read"](filename, true);\n        if (!ret.buffer) {\n            ret = new Uint8Array(ret)\n        }\n        assert(ret.buffer);\n        return ret\n    };\n    if (process["argv"].length > 1) {\n        Module["thisProgram"] = process["argv"][1].replace(/\\\\/g, "/")\n    }\n    Module["arguments"] = process["argv"].slice(2);\n    if (typeof module !== "undefined") {\n        module["exports"] = Module\n    }\n    process["on"]("uncaughtException", (function (ex) {\n        if (!(ex instanceof ExitStatus)) {\n            throw ex\n        }\n    }));\n    process["on"]("unhandledRejection", abort);\n    Module["quit"] = (function (status) {\n        process["exit"](status)\n    });\n    Module["inspect"] = (function () {\n        return "[Emscripten Module object]"\n    })\n} else if (ENVIRONMENT_IS_SHELL) {\n    if (typeof read != "undefined") {\n        Module["read"] = function shell_read(f) {\n            return read(f)\n        }\n    }\n    Module["readBinary"] = function readBinary(f) {\n        var data;\n        if (typeof readbuffer === "function") {\n            return new Uint8Array(readbuffer(f))\n        }\n        data = read(f, "binary");\n        assert(typeof data === "object");\n        return data\n    };\n    if (typeof scriptArgs != "undefined") {\n        Module["arguments"] = scriptArgs\n    } else if (typeof arguments != "undefined") {\n        Module["arguments"] = arguments\n    }\n    if (typeof quit === "function") {\n        Module["quit"] = (function (status) {\n            quit(status)\n        })\n    }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    if (ENVIRONMENT_IS_WEB) {\n        if (document.currentScript) {\n            scriptDirectory = document.currentScript.src\n        }\n    } else {\n        scriptDirectory = self.location.href\n    }\n    if (scriptDirectory.indexOf("blob:") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1)\n    } else {\n        scriptDirectory = ""\n    }\n    Module["read"] = function shell_read(url) {\n        var xhr = new XMLHttpRequest;\n        xhr.open("GET", url, false);\n        xhr.send(null);\n        return xhr.responseText\n    };\n    if (ENVIRONMENT_IS_WORKER) {\n        Module["readBinary"] = function readBinary(url) {\n            var xhr = new XMLHttpRequest;\n            xhr.open("GET", url, false);\n            xhr.responseType = "arraybuffer";\n            xhr.send(null);\n            return new Uint8Array(xhr.response)\n        }\n    }\n    Module["readAsync"] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest;\n        xhr.open("GET", url, true);\n        xhr.responseType = "arraybuffer";\n        xhr.onload = function xhr_onload() {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                onload(xhr.response);\n                return\n            }\n            onerror()\n        };\n        xhr.onerror = onerror;\n        xhr.send(null)\n    };\n    Module["setWindowTitle"] = (function (title) {\n        document.title = title\n    })\n} else { }\nvar out = Module["print"] || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null);\nvar err = Module["printErr"] || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || out);\nfor (key in moduleOverrides) {\n    if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key]\n    }\n}\nmoduleOverrides = undefined;\nvar STACK_ALIGN = 16;\n\nfunction staticAlloc(size) {\n    var ret = STATICTOP;\n    STATICTOP = STATICTOP + size + 15 & -16;\n    return ret\n}\n\nfunction alignMemory(size, factor) {\n    if (!factor) factor = STACK_ALIGN;\n    var ret = size = Math.ceil(size / factor) * factor;\n    return ret\n}\nvar asm2wasmImports = {\n    "f64-rem": (function (x, y) {\n        return x % y\n    }),\n    "debugger": (function () {\n        debugger\n    })\n};\nvar functionPointers = new Array(0);\nvar GLOBAL_BASE = 1024;\nvar ABORT = false;\nvar EXITSTATUS = 0;\n\nfunction assert(condition, text) {\n    if (!condition) {\n        abort("Assertion failed: " + text)\n    }\n}\n\nfunction getCFunc(ident) {\n    var func = Module["_" + ident];\n    assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");\n    return func\n}\nvar JSfuncs = {\n    "stackSave": (function () {\n        stackSave()\n    }),\n    "stackRestore": (function () {\n        stackRestore()\n    }),\n    "arrayToC": (function (arr) {\n        var ret = stackAlloc(arr.length);\n        writeArrayToMemory(arr, ret);\n        return ret\n    }),\n    "stringToC": (function (str) {\n        var ret = 0;\n        if (str !== null && str !== undefined && str !== 0) {\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len)\n        }\n        return ret\n    })\n};\nvar toC = {\n    "string": JSfuncs["stringToC"],\n    "array": JSfuncs["arrayToC"]\n};\n\nfunction ccall(ident, returnType, argTypes, args, opts) {\n    function convertReturnValue(ret) {\n        if (returnType === "string") return Pointer_stringify(ret);\n        if (returnType === "boolean") return Boolean(ret);\n        return ret\n    }\n    var func = getCFunc(ident);\n    var cArgs = [];\n    var stack = 0;\n    if (args) {\n        for (var i = 0; i < args.length; i++) {\n            var converter = toC[argTypes[i]];\n            if (converter) {\n                if (stack === 0) stack = stackSave();\n                cArgs[i] = converter(args[i])\n            } else {\n                cArgs[i] = args[i]\n            }\n        }\n    }\n    var ret = func.apply(null, cArgs);\n    ret = convertReturnValue(ret);\n    if (stack !== 0) stackRestore(stack);\n    return ret\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n    argTypes = argTypes || [];\n    var numericArgs = argTypes.every((function (type) {\n        return type === "number"\n    }));\n    var numericRet = returnType !== "string";\n    if (numericRet && numericArgs && !opts) {\n        return getCFunc(ident)\n    }\n    return (function () {\n        return ccall(ident, returnType, argTypes, arguments, opts)\n    })\n}\n\nfunction setValue(ptr, value, type, noSafe) {\n    type = type || "i8";\n    if (type.charAt(type.length - 1) === "*") type = "i32";\n    switch (type) {\n        case "i1":\n            HEAP8[ptr >> 0] = value;\n            break;\n        case "i8":\n            HEAP8[ptr >> 0] = value;\n            break;\n        case "i16":\n            HEAP16[ptr >> 1] = value;\n            break;\n        case "i32":\n            HEAP32[ptr >> 2] = value;\n            break;\n        case "i64":\n            tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n            break;\n        case "float":\n            HEAPF32[ptr >> 2] = value;\n            break;\n        case "double":\n            HEAPF64[ptr >> 3] = value;\n            break;\n        default:\n            abort("invalid type for setValue: " + type)\n    }\n}\n\nfunction getValue(ptr, type, noSafe) {\n    type = type || "i8";\n    if (type.charAt(type.length - 1) === "*") type = "i32";\n    switch (type) {\n        case "i1":\n            return HEAP8[ptr >> 0];\n        case "i8":\n            return HEAP8[ptr >> 0];\n        case "i16":\n            return HEAP16[ptr >> 1];\n        case "i32":\n            return HEAP32[ptr >> 2];\n        case "i64":\n            return HEAP32[ptr >> 2];\n        case "float":\n            return HEAPF32[ptr >> 2];\n        case "double":\n            return HEAPF64[ptr >> 3];\n        default:\n            abort("invalid type for getValue: " + type)\n    }\n    return null\n}\n\nfunction Pointer_stringify(ptr, length) {\n    if (length === 0 || !ptr) return "";\n    var hasUtf = 0;\n    var t;\n    var i = 0;\n    while (1) {\n        t = HEAPU8[ptr + i >> 0];\n        hasUtf |= t;\n        if (t == 0 && !length) break;\n        i++;\n        if (length && i == length) break\n    }\n    if (!length) length = i;\n    var ret = "";\n    if (hasUtf < 128) {\n        var MAX_CHUNK = 1024;\n        var curr;\n        while (length > 0) {\n            curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n            ret = ret ? ret + curr : curr;\n            ptr += MAX_CHUNK;\n            length -= MAX_CHUNK\n        }\n        return ret\n    }\n    return UTF8ToString(ptr)\n}\nvar UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;\n\nfunction UTF8ArrayToString(u8Array, idx) {\n    var endPtr = idx;\n    while (u8Array[endPtr]) ++endPtr;\n    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))\n    } else {\n        var u0, u1, u2, u3, u4, u5;\n        var str = "";\n        while (1) {\n            u0 = u8Array[idx++];\n            if (!u0) return str;\n            if (!(u0 & 128)) {\n                str += String.fromCharCode(u0);\n                continue\n            }\n            u1 = u8Array[idx++] & 63;\n            if ((u0 & 224) == 192) {\n                str += String.fromCharCode((u0 & 31) << 6 | u1);\n                continue\n            }\n            u2 = u8Array[idx++] & 63;\n            if ((u0 & 240) == 224) {\n                u0 = (u0 & 15) << 12 | u1 << 6 | u2\n            } else {\n                u3 = u8Array[idx++] & 63;\n                if ((u0 & 248) == 240) {\n                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3\n                } else {\n                    u4 = u8Array[idx++] & 63;\n                    if ((u0 & 252) == 248) {\n                        u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4\n                    } else {\n                        u5 = u8Array[idx++] & 63;\n                        u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5\n                    }\n                }\n            }\n            if (u0 < 65536) {\n                str += String.fromCharCode(u0)\n            } else {\n                var ch = u0 - 65536;\n                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)\n            }\n        }\n    }\n}\n\nfunction UTF8ToString(ptr) {\n    return UTF8ArrayToString(HEAPU8, ptr)\n}\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n    if (!(maxBytesToWrite > 0)) return 0;\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1;\n    for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n            var u1 = str.charCodeAt(++i);\n            u = 65536 + ((u & 1023) << 10) | u1 & 1023\n        }\n        if (u <= 127) {\n            if (outIdx >= endIdx) break;\n            outU8Array[outIdx++] = u\n        } else if (u <= 2047) {\n            if (outIdx + 1 >= endIdx) break;\n            outU8Array[outIdx++] = 192 | u >> 6;\n            outU8Array[outIdx++] = 128 | u & 63\n        } else if (u <= 65535) {\n            if (outIdx + 2 >= endIdx) break;\n            outU8Array[outIdx++] = 224 | u >> 12;\n            outU8Array[outIdx++] = 128 | u >> 6 & 63;\n            outU8Array[outIdx++] = 128 | u & 63\n        } else if (u <= 2097151) {\n            if (outIdx + 3 >= endIdx) break;\n            outU8Array[outIdx++] = 240 | u >> 18;\n            outU8Array[outIdx++] = 128 | u >> 12 & 63;\n            outU8Array[outIdx++] = 128 | u >> 6 & 63;\n            outU8Array[outIdx++] = 128 | u & 63\n        } else if (u <= 67108863) {\n            if (outIdx + 4 >= endIdx) break;\n            outU8Array[outIdx++] = 248 | u >> 24;\n            outU8Array[outIdx++] = 128 | u >> 18 & 63;\n            outU8Array[outIdx++] = 128 | u >> 12 & 63;\n            outU8Array[outIdx++] = 128 | u >> 6 & 63;\n            outU8Array[outIdx++] = 128 | u & 63\n        } else {\n            if (outIdx + 5 >= endIdx) break;\n            outU8Array[outIdx++] = 252 | u >> 30;\n            outU8Array[outIdx++] = 128 | u >> 24 & 63;\n            outU8Array[outIdx++] = 128 | u >> 18 & 63;\n            outU8Array[outIdx++] = 128 | u >> 12 & 63;\n            outU8Array[outIdx++] = 128 | u >> 6 & 63;\n            outU8Array[outIdx++] = 128 | u & 63\n        }\n    }\n    outU8Array[outIdx] = 0;\n    return outIdx - startIdx\n}\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)\n}\n\nfunction lengthBytesUTF8(str) {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) {\n            ++len\n        } else if (u <= 2047) {\n            len += 2\n        } else if (u <= 65535) {\n            len += 3\n        } else if (u <= 2097151) {\n            len += 4\n        } else if (u <= 67108863) {\n            len += 5\n        } else {\n            len += 6\n        }\n    }\n    return len\n}\nvar UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;\n\nfunction allocateUTF8(str) {\n    var size = lengthBytesUTF8(str) + 1;\n    var ret = _malloc(size);\n    if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n    return ret\n}\n\nfunction demangle(func) {\n    return func\n}\n\nfunction demangleAll(text) {\n    var regex = /__Z[\\w\\d_]+/g;\n    return text.replace(regex, (function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + " [" + x + "]"\n    }))\n}\n\nfunction jsStackTrace() {\n    var err = new Error;\n    if (!err.stack) {\n        try {\n            throw new Error(0)\n        } catch (e) {\n            err = e\n        }\n        if (!err.stack) {\n            return "(no stack trace available)"\n        }\n    }\n    return err.stack.toString()\n}\n\nfunction stackTrace() {\n    var js = jsStackTrace();\n    if (Module["extraStackTrace"]) js += "\\n" + Module["extraStackTrace"]();\n    return demangleAll(js)\n}\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n    if (x % multiple > 0) {\n        x += multiple - x % multiple\n    }\n    return x\n}\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n    Module["buffer"] = buffer = buf\n}\n\nfunction updateGlobalBufferViews() {\n    Module["HEAP8"] = HEAP8 = new Int8Array(buffer);\n    Module["HEAP16"] = HEAP16 = new Int16Array(buffer);\n    Module["HEAP32"] = HEAP32 = new Int32Array(buffer);\n    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);\n    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);\n    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);\n    Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);\n    Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer)\n}\nvar STATIC_BASE, STATICTOP, staticSealed;\nvar STACK_BASE, STACKTOP, STACK_MAX;\nvar DYNAMIC_BASE, DYNAMICTOP_PTR;\nSTATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\nstaticSealed = false;\n\nfunction abortOnCannotGrowMemory() {\n    abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")\n}\nif (!Module["reallocBuffer"]) Module["reallocBuffer"] = (function (size) {\n    var ret;\n    try {\n        var oldHEAP8 = HEAP8;\n        ret = new ArrayBuffer(size);\n        var temp = new Int8Array(ret);\n        temp.set(oldHEAP8)\n    } catch (e) {\n        return false\n    }\n    var success = _emscripten_replace_memory(ret);\n    if (!success) return false;\n    return ret\n});\n\nfunction enlargeMemory() {\n    var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;\n    var LIMIT = 2147483648 - PAGE_MULTIPLE;\n    if (HEAP32[DYNAMICTOP_PTR >> 2] > LIMIT) {\n        return false\n    }\n    var OLD_TOTAL_MEMORY = TOTAL_MEMORY;\n    TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY);\n    while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR >> 2]) {\n        if (TOTAL_MEMORY <= 536870912) {\n            TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE)\n        } else {\n            TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT)\n        }\n    }\n    var replacement = Module["reallocBuffer"](TOTAL_MEMORY);\n    if (!replacement || replacement.byteLength != TOTAL_MEMORY) {\n        TOTAL_MEMORY = OLD_TOTAL_MEMORY;\n        return false\n    }\n    updateGlobalBuffer(replacement);\n    updateGlobalBufferViews();\n    return true\n}\nvar byteLength;\ntry {\n    byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get);\n    byteLength(new ArrayBuffer(4))\n} catch (e) {\n    byteLength = (function (buffer) {\n        return buffer.byteLength\n    })\n}\nvar TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;\nvar TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 5242880;\nif (TOTAL_MEMORY < TOTAL_STACK) err("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");\nif (Module["buffer"]) {\n    buffer = Module["buffer"]\n} else {\n    if (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function") {\n        Module["wasmMemory"] = new WebAssembly.Memory({\n            "initial": TOTAL_MEMORY / WASM_PAGE_SIZE\n        });\n        buffer = Module["wasmMemory"].buffer\n    } else {\n        buffer = new ArrayBuffer(TOTAL_MEMORY)\n    }\n    Module["buffer"] = buffer\n}\nupdateGlobalBufferViews();\n\nfunction getTotalMemory() {\n    return TOTAL_MEMORY\n}\n\nfunction callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == "function") {\n            callback();\n            continue\n        }\n        var func = callback.func;\n        if (typeof func === "number") {\n            if (callback.arg === undefined) {\n                Module["dynCall_v"](func)\n            } else {\n                Module["dynCall_vi"](func, callback.arg)\n            }\n        } else {\n            func(callback.arg === undefined ? null : callback.arg)\n        }\n    }\n}\nvar __ATPRERUN__ = [];\nvar __ATINIT__ = [];\nvar __ATMAIN__ = [];\nvar __ATEXIT__ = [];\nvar __ATPOSTRUN__ = [];\nvar runtimeInitialized = false;\n\nfunction preRun() {\n    if (Module["preRun"]) {\n        if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];\n        while (Module["preRun"].length) {\n            addOnPreRun(Module["preRun"].shift())\n        }\n    }\n    callRuntimeCallbacks(__ATPRERUN__)\n}\n\nfunction ensureInitRuntime() {\n    if (runtimeInitialized) return;\n    runtimeInitialized = true;\n    callRuntimeCallbacks(__ATINIT__)\n}\n\nfunction preMain() {\n    callRuntimeCallbacks(__ATMAIN__)\n}\n\nfunction postRun() {\n    if (Module["postRun"]) {\n        if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];\n        while (Module["postRun"].length) {\n            addOnPostRun(Module["postRun"].shift())\n        }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__)\n}\n\nfunction addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb)\n}\n\nfunction addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb)\n}\n\nfunction writeArrayToMemory(array, buffer) {\n    HEAP8.set(array, buffer)\n}\nvar Math_abs = Math.abs;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_min = Math.min;\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null;\n\nfunction getUniqueRunDependency(id) {\n    return id\n}\n\nfunction addRunDependency(id) {\n    runDependencies++;\n    if (Module["monitorRunDependencies"]) {\n        Module["monitorRunDependencies"](runDependencies)\n    }\n}\n\nfunction removeRunDependency(id) {\n    runDependencies--;\n    if (Module["monitorRunDependencies"]) {\n        Module["monitorRunDependencies"](runDependencies)\n    }\n    if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n            clearInterval(runDependencyWatcher);\n            runDependencyWatcher = null\n        }\n        if (dependenciesFulfilled) {\n            var callback = dependenciesFulfilled;\n            dependenciesFulfilled = null;\n            callback()\n        }\n    }\n}\nModule["preloadedImages"] = {};\nModule["preloadedAudios"] = {};\nvar dataURIPrefix = "data:application/octet-stream;base64,";\n\nfunction isDataURI(filename) {\n    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0\n}\n\nfunction integrateWasmJS() {\n    var wasmTextFile = "libde265.wast";\n    var wasmBinaryFile = "BLOBURL/libde265.wasm";\n    var asmjsCodeFile = "libde265.temp.asm.js";\n    if (!isDataURI(wasmTextFile)) {\n        wasmTextFile = locateFile(wasmTextFile)\n    }\n    if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = locateFile(wasmBinaryFile)\n    }\n    if (!isDataURI(asmjsCodeFile)) {\n        asmjsCodeFile = locateFile(asmjsCodeFile)\n    }\n    var wasmPageSize = 64 * 1024;\n    var info = {\n        "global": null,\n        "env": null,\n        "asm2wasm": asm2wasmImports,\n        "parent": Module\n    };\n    var exports = null;\n\n    function mergeMemory(newBuffer) {\n        var oldBuffer = Module["buffer"];\n        if (newBuffer.byteLength < oldBuffer.byteLength) {\n            err("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here")\n        }\n        var oldView = new Int8Array(oldBuffer);\n        var newView = new Int8Array(newBuffer);\n        newView.set(oldView);\n        updateGlobalBuffer(newBuffer);\n        updateGlobalBufferViews()\n    }\n\n    function fixImports(imports) {\n        return imports\n    }\n\n    function getBinary() {\n        try {\n            if (Module["wasmBinary"]) {\n                return new Uint8Array(Module["wasmBinary"])\n            }\n            if (Module["readBinary"]) {\n                return Module["readBinary"](wasmBinaryFile)\n            } else {\n                throw "both async and sync fetching of the wasm failed"\n            }\n        } catch (err) {\n            abort(err)\n        }\n    }\n\n    function getBinaryPromise() {\n        if (!Module["wasmBinary"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {\n            return fetch(wasmBinaryFile, {\n                credentials: "same-origin"\n            }).then((function (response) {\n                if (!response["ok"]) {\n                    throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"\n                }\n                return response["arrayBuffer"]()\n            })).catch((function () {\n                return getBinary()\n            }))\n        }\n        return new Promise((function (resolve, reject) {\n            resolve(getBinary())\n        }))\n    }\n\n    function doNativeWasm(global, env, providedBuffer) {\n        if (typeof WebAssembly !== "object") {\n            err("no native wasm support detected");\n            return false\n        }\n        if (!(Module["wasmMemory"] instanceof WebAssembly.Memory)) {\n            err("no native wasm Memory in use");\n            return false\n        }\n        env["memory"] = Module["wasmMemory"];\n        info["global"] = {\n            "NaN": NaN,\n            "Infinity": Infinity\n        };\n        info["global.Math"] = Math;\n        info["env"] = env;\n\n        function receiveInstance(instance, module) {\n            exports = instance.exports;\n            if (exports.memory) mergeMemory(exports.memory);\n            Module["asm"] = exports;\n            Module["usingWasm"] = true;\n            removeRunDependency("wasm-instantiate")\n        }\n        addRunDependency("wasm-instantiate");\n        if (Module["instantiateWasm"]) {\n            try {\n                return Module["instantiateWasm"](info, receiveInstance)\n            } catch (e) {\n                err("Module.instantiateWasm callback failed with error: " + e);\n                return false\n            }\n        }\n\n        function receiveInstantiatedSource(output) {\n            receiveInstance(output["instance"], output["module"])\n        }\n\n        function instantiateArrayBuffer(receiver) {\n            getBinaryPromise().then((function (binary) {\n                return WebAssembly.instantiate(binary, info)\n            })).then(receiver, (function (reason) {\n                err("failed to asynchronously prepare wasm: " + reason);\n                abort(reason)\n            }))\n        }\n        if (!Module["wasmBinary"] && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {\n            WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n                credentials: "same-origin"\n            }), info).then(receiveInstantiatedSource, (function (reason) {\n                err("wasm streaming compile failed: " + reason);\n                err("falling back to ArrayBuffer instantiation");\n                instantiateArrayBuffer(receiveInstantiatedSource)\n            }))\n        } else {\n            instantiateArrayBuffer(receiveInstantiatedSource)\n        }\n        return {}\n    }\n    Module["asmPreload"] = Module["asm"];\n    var asmjsReallocBuffer = Module["reallocBuffer"];\n    var wasmReallocBuffer = (function (size) {\n        var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;\n        size = alignUp(size, PAGE_MULTIPLE);\n        var old = Module["buffer"];\n        var oldSize = old.byteLength;\n        if (Module["usingWasm"]) {\n            try {\n                var result = Module["wasmMemory"].grow((size - oldSize) / wasmPageSize);\n                if (result !== (-1 | 0)) {\n                    return Module["buffer"] = Module["wasmMemory"].buffer\n                } else {\n                    return null\n                }\n            } catch (e) {\n                return null\n            }\n        }\n    });\n    Module["reallocBuffer"] = (function (size) {\n        if (finalMethod === "asmjs") {\n            return asmjsReallocBuffer(size)\n        } else {\n            return wasmReallocBuffer(size)\n        }\n    });\n    var finalMethod = "";\n    Module["asm"] = (function (global, env, providedBuffer) {\n        env = fixImports(env);\n        if (!env["table"]) {\n            var TABLE_SIZE = Module["wasmTableSize"];\n            if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;\n            var MAX_TABLE_SIZE = Module["wasmMaxTableSize"];\n            if (typeof WebAssembly === "object" && typeof WebAssembly.Table === "function") {\n                if (MAX_TABLE_SIZE !== undefined) {\n                    env["table"] = new WebAssembly.Table({\n                        "initial": TABLE_SIZE,\n                        "maximum": MAX_TABLE_SIZE,\n                        "element": "anyfunc"\n                    })\n                } else {\n                    env["table"] = new WebAssembly.Table({\n                        "initial": TABLE_SIZE,\n                        element: "anyfunc"\n                    })\n                }\n            } else {\n                env["table"] = new Array(TABLE_SIZE)\n            }\n            Module["wasmTable"] = env["table"]\n        }\n        if (!env["memoryBase"]) {\n            env["memoryBase"] = Module["STATIC_BASE"]\n        }\n        if (!env["tableBase"]) {\n            env["tableBase"] = 0\n        }\n        var exports;\n        exports = doNativeWasm(global, env, providedBuffer);\n        assert(exports, "no binaryen method succeeded.");\n        return exports\n    })\n}\nintegrateWasmJS();\nSTATIC_BASE = GLOBAL_BASE;\nSTATICTOP = STATIC_BASE + 59632;\n__ATINIT__.push({\n    func: (function () {\n        __GLOBAL__I_000101()\n    })\n}, {\n    func: (function () {\n        __GLOBAL__sub_I_encoder_types_cc()\n    })\n}, {\n    func: (function () {\n        __GLOBAL__sub_I_iostream_cpp()\n    })\n});\nvar STATIC_BUMP = 59632;\nModule["STATIC_BASE"] = STATIC_BASE;\nModule["STATIC_BUMP"] = STATIC_BUMP;\nSTATICTOP += 16;\n\nfunction ___assert_fail(condition, filename, line, func) {\n    abort("Assertion failed: " + Pointer_stringify(condition) + ", at: " + [filename ? Pointer_stringify(filename) : "unknown filename", line, func ? Pointer_stringify(func) : "unknown function"])\n}\n\nfunction ___cxa_allocate_exception(size) {\n    return _malloc(size)\n}\n\nfunction __ZSt18uncaught_exceptionv() {\n    return !!__ZSt18uncaught_exceptionv.uncaught_exception\n}\nvar EXCEPTIONS = {\n    last: 0,\n    caught: [],\n    infos: {},\n    deAdjust: (function (adjusted) {\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n        for (var key in EXCEPTIONS.infos) {\n            var ptr = +key;\n            var info = EXCEPTIONS.infos[ptr];\n            if (info.adjusted === adjusted) {\n                return ptr\n            }\n        }\n        return adjusted\n    }),\n    addRef: (function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount++\n    }),\n    decRef: (function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        assert(info.refcount > 0);\n        info.refcount--;\n        if (info.refcount === 0 && !info.rethrown) {\n            if (info.destructor) {\n                Module["dynCall_vi"](info.destructor, ptr)\n            }\n            delete EXCEPTIONS.infos[ptr];\n            ___cxa_free_exception(ptr)\n        }\n    }),\n    clearRef: (function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount = 0\n    })\n};\n\nfunction ___cxa_pure_virtual() {\n    ABORT = true;\n    throw "Pure virtual function called!"\n}\n\nfunction ___cxa_throw(ptr, type, destructor) {\n    EXCEPTIONS.infos[ptr] = {\n        ptr: ptr,\n        adjusted: ptr,\n        type: type,\n        destructor: destructor,\n        refcount: 0,\n        caught: false,\n        rethrown: false\n    };\n    EXCEPTIONS.last = ptr;\n    if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1\n    } else {\n        __ZSt18uncaught_exceptionv.uncaught_exception++\n    }\n    throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."\n}\n\nfunction ___lock() { }\nvar ERRNO_CODES = {\n    EPERM: 1,\n    ENOENT: 2,\n    ESRCH: 3,\n    EINTR: 4,\n    EIO: 5,\n    ENXIO: 6,\n    E2BIG: 7,\n    ENOEXEC: 8,\n    EBADF: 9,\n    ECHILD: 10,\n    EAGAIN: 11,\n    EWOULDBLOCK: 11,\n    ENOMEM: 12,\n    EACCES: 13,\n    EFAULT: 14,\n    ENOTBLK: 15,\n    EBUSY: 16,\n    EEXIST: 17,\n    EXDEV: 18,\n    ENODEV: 19,\n    ENOTDIR: 20,\n    EISDIR: 21,\n    EINVAL: 22,\n    ENFILE: 23,\n    EMFILE: 24,\n    ENOTTY: 25,\n    ETXTBSY: 26,\n    EFBIG: 27,\n    ENOSPC: 28,\n    ESPIPE: 29,\n    EROFS: 30,\n    EMLINK: 31,\n    EPIPE: 32,\n    EDOM: 33,\n    ERANGE: 34,\n    ENOMSG: 42,\n    EIDRM: 43,\n    ECHRNG: 44,\n    EL2NSYNC: 45,\n    EL3HLT: 46,\n    EL3RST: 47,\n    ELNRNG: 48,\n    EUNATCH: 49,\n    ENOCSI: 50,\n    EL2HLT: 51,\n    EDEADLK: 35,\n    ENOLCK: 37,\n    EBADE: 52,\n    EBADR: 53,\n    EXFULL: 54,\n    ENOANO: 55,\n    EBADRQC: 56,\n    EBADSLT: 57,\n    EDEADLOCK: 35,\n    EBFONT: 59,\n    ENOSTR: 60,\n    ENODATA: 61,\n    ETIME: 62,\n    ENOSR: 63,\n    ENONET: 64,\n    ENOPKG: 65,\n    EREMOTE: 66,\n    ENOLINK: 67,\n    EADV: 68,\n    ESRMNT: 69,\n    ECOMM: 70,\n    EPROTO: 71,\n    EMULTIHOP: 72,\n    EDOTDOT: 73,\n    EBADMSG: 74,\n    ENOTUNIQ: 76,\n    EBADFD: 77,\n    EREMCHG: 78,\n    ELIBACC: 79,\n    ELIBBAD: 80,\n    ELIBSCN: 81,\n    ELIBMAX: 82,\n    ELIBEXEC: 83,\n    ENOSYS: 38,\n    ENOTEMPTY: 39,\n    ENAMETOOLONG: 36,\n    ELOOP: 40,\n    EOPNOTSUPP: 95,\n    EPFNOSUPPORT: 96,\n    ECONNRESET: 104,\n    ENOBUFS: 105,\n    EAFNOSUPPORT: 97,\n    EPROTOTYPE: 91,\n    ENOTSOCK: 88,\n    ENOPROTOOPT: 92,\n    ESHUTDOWN: 108,\n    ECONNREFUSED: 111,\n    EADDRINUSE: 98,\n    ECONNABORTED: 103,\n    ENETUNREACH: 101,\n    ENETDOWN: 100,\n    ETIMEDOUT: 110,\n    EHOSTDOWN: 112,\n    EHOSTUNREACH: 113,\n    EINPROGRESS: 115,\n    EALREADY: 114,\n    EDESTADDRREQ: 89,\n    EMSGSIZE: 90,\n    EPROTONOSUPPORT: 93,\n    ESOCKTNOSUPPORT: 94,\n    EADDRNOTAVAIL: 99,\n    ENETRESET: 102,\n    EISCONN: 106,\n    ENOTCONN: 107,\n    ETOOMANYREFS: 109,\n    EUSERS: 87,\n    EDQUOT: 122,\n    ESTALE: 116,\n    ENOTSUP: 95,\n    ENOMEDIUM: 123,\n    EILSEQ: 84,\n    EOVERFLOW: 75,\n    ECANCELED: 125,\n    ENOTRECOVERABLE: 131,\n    EOWNERDEAD: 130,\n    ESTRPIPE: 86\n};\n\nfunction ___setErrNo(value) {\n    if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value;\n    return value\n}\n\nfunction ___map_file(pathname, size) {\n    ___setErrNo(ERRNO_CODES.EPERM);\n    return -1\n}\nvar ERRNO_MESSAGES = {\n    0: "Success",\n    1: "Not super-user",\n    2: "No such file or directory",\n    3: "No such process",\n    4: "Interrupted system call",\n    5: "I/O error",\n    6: "No such device or address",\n    7: "Arg list too long",\n    8: "Exec format error",\n    9: "Bad file number",\n    10: "No children",\n    11: "No more processes",\n    12: "Not enough core",\n    13: "Permission denied",\n    14: "Bad address",\n    15: "Block device required",\n    16: "Mount device busy",\n    17: "File exists",\n    18: "Cross-device link",\n    19: "No such device",\n    20: "Not a directory",\n    21: "Is a directory",\n    22: "Invalid argument",\n    23: "Too many open files in system",\n    24: "Too many open files",\n    25: "Not a typewriter",\n    26: "Text file busy",\n    27: "File too large",\n    28: "No space left on device",\n    29: "Illegal seek",\n    30: "Read only file system",\n    31: "Too many links",\n    32: "Broken pipe",\n    33: "Math arg out of domain of func",\n    34: "Math result not representable",\n    35: "File locking deadlock error",\n    36: "File or path name too long",\n    37: "No record locks available",\n    38: "Function not implemented",\n    39: "Directory not empty",\n    40: "Too many symbolic links",\n    42: "No message of desired type",\n    43: "Identifier removed",\n    44: "Channel number out of range",\n    45: "Level 2 not synchronized",\n    46: "Level 3 halted",\n    47: "Level 3 reset",\n    48: "Link number out of range",\n    49: "Protocol driver not attached",\n    50: "No CSI structure available",\n    51: "Level 2 halted",\n    52: "Invalid exchange",\n    53: "Invalid request descriptor",\n    54: "Exchange full",\n    55: "No anode",\n    56: "Invalid request code",\n    57: "Invalid slot",\n    59: "Bad font file fmt",\n    60: "Device not a stream",\n    61: "No data (for no delay io)",\n    62: "Timer expired",\n    63: "Out of streams resources",\n    64: "Machine is not on the network",\n    65: "Package not installed",\n    66: "The object is remote",\n    67: "The link has been severed",\n    68: "Advertise error",\n    69: "Srmount error",\n    70: "Communication error on send",\n    71: "Protocol error",\n    72: "Multihop attempted",\n    73: "Cross mount point (not really error)",\n    74: "Trying to read unreadable message",\n    75: "Value too large for defined data type",\n    76: "Given log. name not unique",\n    77: "f.d. invalid for this operation",\n    78: "Remote address changed",\n    79: "Can   access a needed shared lib",\n    80: "Accessing a corrupted shared lib",\n    81: ".lib section in a.out corrupted",\n    82: "Attempting to link in too many libs",\n    83: "Attempting to exec a shared library",\n    84: "Illegal byte sequence",\n    86: "Streams pipe error",\n    87: "Too many users",\n    88: "Socket operation on non-socket",\n    89: "Destination address required",\n    90: "Message too long",\n    91: "Protocol wrong type for socket",\n    92: "Protocol not available",\n    93: "Unknown protocol",\n    94: "Socket type not supported",\n    95: "Not supported",\n    96: "Protocol family not supported",\n    97: "Address family not supported by protocol family",\n    98: "Address already in use",\n    99: "Address not available",\n    100: "Network interface is not configured",\n    101: "Network is unreachable",\n    102: "Connection reset by network",\n    103: "Connection aborted",\n    104: "Connection reset by peer",\n    105: "No buffer space available",\n    106: "Socket is already connected",\n    107: "Socket is not connected",\n    108: "Can't send after socket shutdown",\n    109: "Too many references",\n    110: "Connection timed out",\n    111: "Connection refused",\n    112: "Host is down",\n    113: "Host is unreachable",\n    114: "Socket already connected",\n    115: "Connection already in progress",\n    116: "Stale file handle",\n    122: "Quota exceeded",\n    123: "No medium (in tape drive)",\n    125: "Operation canceled",\n    130: "Previous owner died",\n    131: "State not recoverable"\n};\nvar PATH = {\n    splitPath: (function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1)\n    }),\n    normalizeArray: (function (parts, allowAboveRoot) {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n            var last = parts[i];\n            if (last === ".") {\n                parts.splice(i, 1)\n            } else if (last === "..") {\n                parts.splice(i, 1);\n                up++\n            } else if (up) {\n                parts.splice(i, 1);\n                up--\n            }\n        }\n        if (allowAboveRoot) {\n            for (; up; up--) {\n                parts.unshift("..")\n            }\n        }\n        return parts\n    }),\n    normalize: (function (path) {\n        var isAbsolute = path.charAt(0) === "/",\n            trailingSlash = path.substr(-1) === "/";\n        path = PATH.normalizeArray(path.split("/").filter((function (p) {\n            return !!p\n        })), !isAbsolute).join("/");\n        if (!path && !isAbsolute) {\n            path = "."\n        }\n        if (path && trailingSlash) {\n            path += "/"\n        }\n        return (isAbsolute ? "/" : "") + path\n    }),\n    dirname: (function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n            return "."\n        }\n        if (dir) {\n            dir = dir.substr(0, dir.length - 1)\n        }\n        return root + dir\n    }),\n    basename: (function (path) {\n        if (path === "/") return "/";\n        var lastSlash = path.lastIndexOf("/");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1)\n    }),\n    extname: (function (path) {\n        return PATH.splitPath(path)[3]\n    }),\n    join: (function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join("/"))\n    }),\n    join2: (function (l, r) {\n        return PATH.normalize(l + "/" + r)\n    }),\n    resolve: (function () {\n        var resolvedPath = "",\n            resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            var path = i >= 0 ? arguments[i] : FS.cwd();\n            if (typeof path !== "string") {\n                throw new TypeError("Arguments to path.resolve must be strings")\n            } else if (!path) {\n                return ""\n            }\n            resolvedPath = path + "/" + resolvedPath;\n            resolvedAbsolute = path.charAt(0) === "/"\n        }\n        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((function (p) {\n            return !!p\n        })), !resolvedAbsolute).join("/");\n        return (resolvedAbsolute ? "/" : "") + resolvedPath || "."\n    }),\n    relative: (function (from, to) {\n        from = PATH.resolve(from).substr(1);\n        to = PATH.resolve(to).substr(1);\n\n        function trim(arr) {\n            var start = 0;\n            for (; start < arr.length; start++) {\n                if (arr[start] !== "") break\n            }\n            var end = arr.length - 1;\n            for (; end >= 0; end--) {\n                if (arr[end] !== "") break\n            }\n            if (start > end) return [];\n            return arr.slice(start, end - start + 1)\n        }\n        var fromParts = trim(from.split("/"));\n        var toParts = trim(to.split("/"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                samePartsLength = i;\n                break\n            }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n            outputParts.push("..")\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join("/")\n    })\n};\nvar TTY = {\n    ttys: [],\n    init: (function () { }),\n    shutdown: (function () { }),\n    register: (function (dev, ops) {\n        TTY.ttys[dev] = {\n            input: [],\n            output: [],\n            ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops)\n    }),\n    stream_ops: {\n        open: (function (stream) {\n            var tty = TTY.ttys[stream.node.rdev];\n            if (!tty) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n            }\n            stream.tty = tty;\n            stream.seekable = false\n        }),\n        close: (function (stream) {\n            stream.tty.ops.flush(stream.tty)\n        }),\n        flush: (function (stream) {\n            stream.tty.ops.flush(stream.tty)\n        }),\n        read: (function (stream, buffer, offset, length, pos) {\n            if (!stream.tty || !stream.tty.ops.get_char) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENXIO)\n            }\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n                var result;\n                try {\n                    result = stream.tty.ops.get_char(stream.tty)\n                } catch (e) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EIO)\n                }\n                if (result === undefined && bytesRead === 0) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\n                }\n                if (result === null || result === undefined) break;\n                bytesRead++;\n                buffer[offset + i] = result\n            }\n            if (bytesRead) {\n                stream.node.timestamp = Date.now()\n            }\n            return bytesRead\n        }),\n        write: (function (stream, buffer, offset, length, pos) {\n            if (!stream.tty || !stream.tty.ops.put_char) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENXIO)\n            }\n            for (var i = 0; i < length; i++) {\n                try {\n                    stream.tty.ops.put_char(stream.tty, buffer[offset + i])\n                } catch (e) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EIO)\n                }\n            }\n            if (length) {\n                stream.node.timestamp = Date.now()\n            }\n            return i\n        })\n    },\n    default_tty_ops: {\n        get_char: (function (tty) {\n            if (!tty.input.length) {\n                var result = null;\n                if (ENVIRONMENT_IS_NODE) {\n                    var BUFSIZE = 256;\n                    var buf = new Buffer(BUFSIZE);\n                    var bytesRead = 0;\n                    var isPosixPlatform = process.platform != "win32";\n                    var fd = process.stdin.fd;\n                    if (isPosixPlatform) {\n                        var usingDevice = false;\n                        try {\n                            fd = fs.openSync("/dev/stdin", "r");\n                            usingDevice = true\n                        } catch (e) { }\n                    }\n                    try {\n                        bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null)\n                    } catch (e) {\n                        if (e.toString().indexOf("EOF") != -1) bytesRead = 0;\n                        else throw e\n                    }\n                    if (usingDevice) {\n                        fs.closeSync(fd)\n                    }\n                    if (bytesRead > 0) {\n                        result = buf.slice(0, bytesRead).toString("utf-8")\n                    } else {\n                        result = null\n                    }\n                } else if (typeof window != "undefined" && typeof window.prompt == "function") {\n                    result = window.prompt("Input: ");\n                    if (result !== null) {\n                        result += "\\n"\n                    }\n                } else if (typeof readline == "function") {\n                    result = readline();\n                    if (result !== null) {\n                        result += "\\n"\n                    }\n                }\n                if (!result) {\n                    return null\n                }\n                tty.input = intArrayFromString(result, true)\n            }\n            return tty.input.shift()\n        }),\n        put_char: (function (tty, val) {\n            if (val === null || val === 10) {\n                out(UTF8ArrayToString(tty.output, 0));\n                tty.output = []\n            } else {\n                if (val != 0) tty.output.push(val)\n            }\n        }),\n        flush: (function (tty) {\n            if (tty.output && tty.output.length > 0) {\n                out(UTF8ArrayToString(tty.output, 0));\n                tty.output = []\n            }\n        })\n    },\n    default_tty1_ops: {\n        put_char: (function (tty, val) {\n            if (val === null || val === 10) {\n                err(UTF8ArrayToString(tty.output, 0));\n                tty.output = []\n            } else {\n                if (val != 0) tty.output.push(val)\n            }\n        }),\n        flush: (function (tty) {\n            if (tty.output && tty.output.length > 0) {\n                err(UTF8ArrayToString(tty.output, 0));\n                tty.output = []\n            }\n        })\n    }\n};\nvar MEMFS = {\n    ops_table: null,\n    mount: (function (mount) {\n        return MEMFS.createNode(null, "/", 16384 | 511, 0)\n    }),\n    createNode: (function (parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        if (!MEMFS.ops_table) {\n            MEMFS.ops_table = {\n                dir: {\n                    node: {\n                        getattr: MEMFS.node_ops.getattr,\n                        setattr: MEMFS.node_ops.setattr,\n                        lookup: MEMFS.node_ops.lookup,\n                        mknod: MEMFS.node_ops.mknod,\n                        rename: MEMFS.node_ops.rename,\n                        unlink: MEMFS.node_ops.unlink,\n                        rmdir: MEMFS.node_ops.rmdir,\n                        readdir: MEMFS.node_ops.readdir,\n                        symlink: MEMFS.node_ops.symlink\n                    },\n                    stream: {\n                        llseek: MEMFS.stream_ops.llseek\n                    }\n                },\n                file: {\n                    node: {\n                        getattr: MEMFS.node_ops.getattr,\n                        setattr: MEMFS.node_ops.setattr\n                    },\n                    stream: {\n                        llseek: MEMFS.stream_ops.llseek,\n                        read: MEMFS.stream_ops.read,\n                        write: MEMFS.stream_ops.write,\n                        allocate: MEMFS.stream_ops.allocate,\n                        mmap: MEMFS.stream_ops.mmap,\n                        msync: MEMFS.stream_ops.msync\n                    }\n                },\n                link: {\n                    node: {\n                        getattr: MEMFS.node_ops.getattr,\n                        setattr: MEMFS.node_ops.setattr,\n                        readlink: MEMFS.node_ops.readlink\n                    },\n                    stream: {}\n                },\n                chrdev: {\n                    node: {\n                        getattr: MEMFS.node_ops.getattr,\n                        setattr: MEMFS.node_ops.setattr\n                    },\n                    stream: FS.chrdev_stream_ops\n                }\n            }\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n            node.node_ops = MEMFS.ops_table.dir.node;\n            node.stream_ops = MEMFS.ops_table.dir.stream;\n            node.contents = {}\n        } else if (FS.isFile(node.mode)) {\n            node.node_ops = MEMFS.ops_table.file.node;\n            node.stream_ops = MEMFS.ops_table.file.stream;\n            node.usedBytes = 0;\n            node.contents = null\n        } else if (FS.isLink(node.mode)) {\n            node.node_ops = MEMFS.ops_table.link.node;\n            node.stream_ops = MEMFS.ops_table.link.stream\n        } else if (FS.isChrdev(node.mode)) {\n            node.node_ops = MEMFS.ops_table.chrdev.node;\n            node.stream_ops = MEMFS.ops_table.chrdev.stream\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n            parent.contents[name] = node\n        }\n        return node\n    }),\n    getFileDataAsRegularArray: (function (node) {\n        if (node.contents && node.contents.subarray) {\n            var arr = [];\n            for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n            return arr\n        }\n        return node.contents\n    }),\n    getFileDataAsTypedArray: (function (node) {\n        if (!node.contents) return new Uint8Array;\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents)\n    }),\n    expandFileStorage: (function (node, newCapacity) {\n        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {\n            node.contents = MEMFS.getFileDataAsRegularArray(node);\n            node.usedBytes = node.contents.length\n        }\n        if (!node.contents || node.contents.subarray) {\n            var prevCapacity = node.contents ? node.contents.length : 0;\n            if (prevCapacity >= newCapacity) return;\n            var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);\n            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n            var oldContents = node.contents;\n            node.contents = new Uint8Array(newCapacity);\n            if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n            return\n        }\n        if (!node.contents && newCapacity > 0) node.contents = [];\n        while (node.contents.length < newCapacity) node.contents.push(0)\n    }),\n    resizeFileStorage: (function (node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n            node.contents = null;\n            node.usedBytes = 0;\n            return\n        }\n        if (!node.contents || node.contents.subarray) {\n            var oldContents = node.contents;\n            node.contents = new Uint8Array(new ArrayBuffer(newSize));\n            if (oldContents) {\n                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)))\n            }\n            node.usedBytes = newSize;\n            return\n        }\n        if (!node.contents) node.contents = [];\n        if (node.contents.length > newSize) node.contents.length = newSize;\n        else\n            while (node.contents.length < newSize) node.contents.push(0);\n        node.usedBytes = newSize\n    }),\n    node_ops: {\n        getattr: (function (node) {\n            var attr = {};\n            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n            attr.ino = node.id;\n            attr.mode = node.mode;\n            attr.nlink = 1;\n            attr.uid = 0;\n            attr.gid = 0;\n            attr.rdev = node.rdev;\n            if (FS.isDir(node.mode)) {\n                attr.size = 4096\n            } else if (FS.isFile(node.mode)) {\n                attr.size = node.usedBytes\n            } else if (FS.isLink(node.mode)) {\n                attr.size = node.link.length\n            } else {\n                attr.size = 0\n            }\n            attr.atime = new Date(node.timestamp);\n            attr.mtime = new Date(node.timestamp);\n            attr.ctime = new Date(node.timestamp);\n            attr.blksize = 4096;\n            attr.blocks = Math.ceil(attr.size / attr.blksize);\n            return attr\n        }),\n        setattr: (function (node, attr) {\n            if (attr.mode !== undefined) {\n                node.mode = attr.mode\n            }\n            if (attr.timestamp !== undefined) {\n                node.timestamp = attr.timestamp\n            }\n            if (attr.size !== undefined) {\n                MEMFS.resizeFileStorage(node, attr.size)\n            }\n        }),\n        lookup: (function (parent, name) {\n            throw FS.genericErrors[ERRNO_CODES.ENOENT]\n        }),\n        mknod: (function (parent, name, mode, dev) {\n            return MEMFS.createNode(parent, name, mode, dev)\n        }),\n        rename: (function (old_node, new_dir, new_name) {\n            if (FS.isDir(old_node.mode)) {\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name)\n                } catch (e) { }\n                if (new_node) {\n                    for (var i in new_node.contents) {\n                        throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)\n                    }\n                }\n            }\n            delete old_node.parent.contents[old_node.name];\n            old_node.name = new_name;\n            new_dir.contents[new_name] = old_node;\n            old_node.parent = new_dir\n        }),\n        unlink: (function (parent, name) {\n            delete parent.contents[name]\n        }),\n        rmdir: (function (parent, name) {\n            var node = FS.lookupNode(parent, name);\n            for (var i in node.contents) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)\n            }\n            delete parent.contents[name]\n        }),\n        readdir: (function (node) {\n            var entries = [".", ".."];\n            for (var key in node.contents) {\n                if (!node.contents.hasOwnProperty(key)) {\n                    continue\n                }\n                entries.push(key)\n            }\n            return entries\n        }),\n        symlink: (function (parent, newname, oldpath) {\n            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n            node.link = oldpath;\n            return node\n        }),\n        readlink: (function (node) {\n            if (!FS.isLink(node.mode)) {\n                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n            }\n            return node.link\n        })\n    },\n    stream_ops: {\n        read: (function (stream, buffer, offset, length, position) {\n            var contents = stream.node.contents;\n            if (position >= stream.node.usedBytes) return 0;\n            var size = Math.min(stream.node.usedBytes - position, length);\n            assert(size >= 0);\n            if (size > 8 && contents.subarray) {\n                buffer.set(contents.subarray(position, position + size), offset)\n            } else {\n                for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i]\n            }\n            return size\n        }),\n        write: (function (stream, buffer, offset, length, position, canOwn) {\n            canOwn = false;\n            if (!length) return 0;\n            var node = stream.node;\n            node.timestamp = Date.now();\n            if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                if (canOwn) {\n                    node.contents = buffer.subarray(offset, offset + length);\n                    node.usedBytes = length;\n                    return length\n                } else if (node.usedBytes === 0 && position === 0) {\n                    node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\n                    node.usedBytes = length;\n                    return length\n                } else if (position + length <= node.usedBytes) {\n                    node.contents.set(buffer.subarray(offset, offset + length), position);\n                    return length\n                }\n            }\n            MEMFS.expandFileStorage(node, position + length);\n            if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);\n            else {\n                for (var i = 0; i < length; i++) {\n                    node.contents[position + i] = buffer[offset + i]\n                }\n            }\n            node.usedBytes = Math.max(node.usedBytes, position + length);\n            return length\n        }),\n        llseek: (function (stream, offset, whence) {\n            var position = offset;\n            if (whence === 1) {\n                position += stream.position\n            } else if (whence === 2) {\n                if (FS.isFile(stream.node.mode)) {\n                    position += stream.node.usedBytes\n                }\n            }\n            if (position < 0) {\n                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n            }\n            return position\n        }),\n        allocate: (function (stream, offset, length) {\n            MEMFS.expandFileStorage(stream.node, offset + length);\n            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length)\n        }),\n        mmap: (function (stream, buffer, offset, length, position, prot, flags) {\n            if (!FS.isFile(stream.node.mode)) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n            }\n            var ptr;\n            var allocated;\n            var contents = stream.node.contents;\n            if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {\n                allocated = false;\n                ptr = contents.byteOffset\n            } else {\n                if (position > 0 || position + length < stream.node.usedBytes) {\n                    if (contents.subarray) {\n                        contents = contents.subarray(position, position + length)\n                    } else {\n                        contents = Array.prototype.slice.call(contents, position, position + length)\n                    }\n                }\n                allocated = true;\n                ptr = _malloc(length);\n                if (!ptr) {\n                    throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)\n                }\n                buffer.set(contents, ptr)\n            }\n            return {\n                ptr: ptr,\n                allocated: allocated\n            }\n        }),\n        msync: (function (stream, buffer, offset, length, mmapFlags) {\n            if (!FS.isFile(stream.node.mode)) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n            }\n            if (mmapFlags & 2) {\n                return 0\n            }\n            var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n            return 0\n        })\n    }\n};\nvar IDBFS = {\n    dbs: {},\n    indexedDB: (function () {\n        if (typeof indexedDB !== "undefined") return indexedDB;\n        var ret = null;\n        if (typeof window === "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        assert(ret, "IDBFS used, but indexedDB not supported");\n        return ret\n    }),\n    DB_VERSION: 21,\n    DB_STORE_NAME: "FILE_DATA",\n    mount: (function (mount) {\n        return MEMFS.mount.apply(null, arguments)\n    }),\n    syncfs: (function (mount, populate, callback) {\n        IDBFS.getLocalSet(mount, (function (err, local) {\n            if (err) return callback(err);\n            IDBFS.getRemoteSet(mount, (function (err, remote) {\n                if (err) return callback(err);\n                var src = populate ? remote : local;\n                var dst = populate ? local : remote;\n                IDBFS.reconcile(src, dst, callback)\n            }))\n        }))\n    }),\n    getDB: (function (name, callback) {\n        var db = IDBFS.dbs[name];\n        if (db) {\n            return callback(null, db)\n        }\n        var req;\n        try {\n            req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION)\n        } catch (e) {\n            return callback(e)\n        }\n        if (!req) {\n            return callback("Unable to connect to IndexedDB")\n        }\n        req.onupgradeneeded = (function (e) {\n            var db = e.target.result;\n            var transaction = e.target.transaction;\n            var fileStore;\n            if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\n                fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME)\n            } else {\n                fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME)\n            }\n            if (!fileStore.indexNames.contains("timestamp")) {\n                fileStore.createIndex("timestamp", "timestamp", {\n                    unique: false\n                })\n            }\n        });\n        req.onsuccess = (function () {\n            db = req.result;\n            IDBFS.dbs[name] = db;\n            callback(null, db)\n        });\n        req.onerror = (function (e) {\n            callback(this.error);\n            e.preventDefault()\n        })\n    }),\n    getLocalSet: (function (mount, callback) {\n        var entries = {};\n\n        function isRealDir(p) {\n            return p !== "." && p !== ".."\n        }\n\n        function toAbsolute(root) {\n            return (function (p) {\n                return PATH.join2(root, p)\n            })\n        }\n        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n        while (check.length) {\n            var path = check.pop();\n            var stat;\n            try {\n                stat = FS.stat(path)\n            } catch (e) {\n                return callback(e)\n            }\n            if (FS.isDir(stat.mode)) {\n                check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)))\n            }\n            entries[path] = {\n                timestamp: stat.mtime\n            }\n        }\n        return callback(null, {\n            type: "local",\n            entries: entries\n        })\n    }),\n    getRemoteSet: (function (mount, callback) {\n        var entries = {};\n        IDBFS.getDB(mount.mountpoint, (function (err, db) {\n            if (err) return callback(err);\n            try {\n                var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly");\n                transaction.onerror = (function (e) {\n                    callback(this.error);\n                    e.preventDefault()\n                });\n                var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n                var index = store.index("timestamp");\n                index.openKeyCursor().onsuccess = (function (event) {\n                    var cursor = event.target.result;\n                    if (!cursor) {\n                        return callback(null, {\n                            type: "remote",\n                            db: db,\n                            entries: entries\n                        })\n                    }\n                    entries[cursor.primaryKey] = {\n                        timestamp: cursor.key\n                    };\n                    cursor.continue()\n                })\n            } catch (e) {\n                return callback(e)\n            }\n        }))\n    }),\n    loadLocalEntry: (function (path, callback) {\n        var stat, node;\n        try {\n            var lookup = FS.lookupPath(path);\n            node = lookup.node;\n            stat = FS.stat(path)\n        } catch (e) {\n            return callback(e)\n        }\n        if (FS.isDir(stat.mode)) {\n            return callback(null, {\n                timestamp: stat.mtime,\n                mode: stat.mode\n            })\n        } else if (FS.isFile(stat.mode)) {\n            node.contents = MEMFS.getFileDataAsTypedArray(node);\n            return callback(null, {\n                timestamp: stat.mtime,\n                mode: stat.mode,\n                contents: node.contents\n            })\n        } else {\n            return callback(new Error("node type not supported"))\n        }\n    }),\n    storeLocalEntry: (function (path, entry, callback) {\n        try {\n            if (FS.isDir(entry.mode)) {\n                FS.mkdir(path, entry.mode)\n            } else if (FS.isFile(entry.mode)) {\n                FS.writeFile(path, entry.contents, {\n                    canOwn: true\n                })\n            } else {\n                return callback(new Error("node type not supported"))\n            }\n            FS.chmod(path, entry.mode);\n            FS.utime(path, entry.timestamp, entry.timestamp)\n        } catch (e) {\n            return callback(e)\n        }\n        callback(null)\n    }),\n    removeLocalEntry: (function (path, callback) {\n        try {\n            var lookup = FS.lookupPath(path);\n            var stat = FS.stat(path);\n            if (FS.isDir(stat.mode)) {\n                FS.rmdir(path)\n            } else if (FS.isFile(stat.mode)) {\n                FS.unlink(path)\n            }\n        } catch (e) {\n            return callback(e)\n        }\n        callback(null)\n    }),\n    loadRemoteEntry: (function (store, path, callback) {\n        var req = store.get(path);\n        req.onsuccess = (function (event) {\n            callback(null, event.target.result)\n        });\n        req.onerror = (function (e) {\n            callback(this.error);\n            e.preventDefault()\n        })\n    }),\n    storeRemoteEntry: (function (store, path, entry, callback) {\n        var req = store.put(entry, path);\n        req.onsuccess = (function () {\n            callback(null)\n        });\n        req.onerror = (function (e) {\n            callback(this.error);\n            e.preventDefault()\n        })\n    }),\n    removeRemoteEntry: (function (store, path, callback) {\n        var req = store.delete(path);\n        req.onsuccess = (function () {\n            callback(null)\n        });\n        req.onerror = (function (e) {\n            callback(this.error);\n            e.preventDefault()\n        })\n    }),\n    reconcile: (function (src, dst, callback) {\n        var total = 0;\n        var create = [];\n        Object.keys(src.entries).forEach((function (key) {\n            var e = src.entries[key];\n            var e2 = dst.entries[key];\n            if (!e2 || e.timestamp > e2.timestamp) {\n                create.push(key);\n                total++\n            }\n        }));\n        var remove = [];\n        Object.keys(dst.entries).forEach((function (key) {\n            var e = dst.entries[key];\n            var e2 = src.entries[key];\n            if (!e2) {\n                remove.push(key);\n                total++\n            }\n        }));\n        if (!total) {\n            return callback(null)\n        }\n        var completed = 0;\n        var db = src.type === "remote" ? src.db : dst.db;\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readwrite");\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n\n        function done(err) {\n            if (err) {\n                if (!done.errored) {\n                    done.errored = true;\n                    return callback(err)\n                }\n                return\n            }\n            if (++completed >= total) {\n                return callback(null)\n            }\n        }\n        transaction.onerror = (function (e) {\n            done(this.error);\n            e.preventDefault()\n        });\n        create.sort().forEach((function (path) {\n            if (dst.type === "local") {\n                IDBFS.loadRemoteEntry(store, path, (function (err, entry) {\n                    if (err) return done(err);\n                    IDBFS.storeLocalEntry(path, entry, done)\n                }))\n            } else {\n                IDBFS.loadLocalEntry(path, (function (err, entry) {\n                    if (err) return done(err);\n                    IDBFS.storeRemoteEntry(store, path, entry, done)\n                }))\n            }\n        }));\n        remove.sort().reverse().forEach((function (path) {\n            if (dst.type === "local") {\n                IDBFS.removeLocalEntry(path, done)\n            } else {\n                IDBFS.removeRemoteEntry(store, path, done)\n            }\n        }))\n    })\n};\nvar NODEFS = {\n    isWindows: false,\n    staticInit: (function () {\n        NODEFS.isWindows = !!process.platform.match(/^win/);\n        var flags = process["binding"]("constants");\n        if (flags["fs"]) {\n            flags = flags["fs"]\n        }\n        NODEFS.flagsForNodeMap = {\n            "1024": flags["O_APPEND"],\n            "64": flags["O_CREAT"],\n            "128": flags["O_EXCL"],\n            "0": flags["O_RDONLY"],\n            "2": flags["O_RDWR"],\n            "4096": flags["O_SYNC"],\n            "512": flags["O_TRUNC"],\n            "1": flags["O_WRONLY"]\n        }\n    }),\n    bufferFrom: (function (arrayBuffer) {\n        return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer)\n    }),\n    mount: (function (mount) {\n        assert(ENVIRONMENT_IS_NODE);\n        return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0)\n    }),\n    createNode: (function (parent, name, mode, dev) {\n        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        var node = FS.createNode(parent, name, mode);\n        node.node_ops = NODEFS.node_ops;\n        node.stream_ops = NODEFS.stream_ops;\n        return node\n    }),\n    getMode: (function (path) {\n        var stat;\n        try {\n            stat = fs.lstatSync(path);\n            if (NODEFS.isWindows) {\n                stat.mode = stat.mode | (stat.mode & 292) >> 2\n            }\n        } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code])\n        }\n        return stat.mode\n    }),\n    realPath: (function (node) {\n        var parts = [];\n        while (node.parent !== node) {\n            parts.push(node.name);\n            node = node.parent\n        }\n        parts.push(node.mount.opts.root);\n        parts.reverse();\n        return PATH.join.apply(null, parts)\n    }),\n    flagsForNode: (function (flags) {\n        flags &= ~2097152;\n        flags &= ~2048;\n        flags &= ~32768;\n        flags &= ~524288;\n        var newFlags = 0;\n        for (var k in NODEFS.flagsForNodeMap) {\n            if (flags & k) {\n                newFlags |= NODEFS.flagsForNodeMap[k];\n                flags ^= k\n            }\n        }\n        if (!flags) {\n            return newFlags\n        } else {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n    }),\n    node_ops: {\n        getattr: (function (node) {\n            var path = NODEFS.realPath(node);\n            var stat;\n            try {\n                stat = fs.lstatSync(path)\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n            if (NODEFS.isWindows && !stat.blksize) {\n                stat.blksize = 4096\n            }\n            if (NODEFS.isWindows && !stat.blocks) {\n                stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0\n            }\n            return {\n                dev: stat.dev,\n                ino: stat.ino,\n                mode: stat.mode,\n                nlink: stat.nlink,\n                uid: stat.uid,\n                gid: stat.gid,\n                rdev: stat.rdev,\n                size: stat.size,\n                atime: stat.atime,\n                mtime: stat.mtime,\n                ctime: stat.ctime,\n                blksize: stat.blksize,\n                blocks: stat.blocks\n            }\n        }),\n        setattr: (function (node, attr) {\n            var path = NODEFS.realPath(node);\n            try {\n                if (attr.mode !== undefined) {\n                    fs.chmodSync(path, attr.mode);\n                    node.mode = attr.mode\n                }\n                if (attr.timestamp !== undefined) {\n                    var date = new Date(attr.timestamp);\n                    fs.utimesSync(path, date, date)\n                }\n                if (attr.size !== undefined) {\n                    fs.truncateSync(path, attr.size)\n                }\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        lookup: (function (parent, name) {\n            var path = PATH.join2(NODEFS.realPath(parent), name);\n            var mode = NODEFS.getMode(path);\n            return NODEFS.createNode(parent, name, mode)\n        }),\n        mknod: (function (parent, name, mode, dev) {\n            var node = NODEFS.createNode(parent, name, mode, dev);\n            var path = NODEFS.realPath(node);\n            try {\n                if (FS.isDir(node.mode)) {\n                    fs.mkdirSync(path, node.mode)\n                } else {\n                    fs.writeFileSync(path, "", {\n                        mode: node.mode\n                    })\n                }\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n            return node\n        }),\n        rename: (function (oldNode, newDir, newName) {\n            var oldPath = NODEFS.realPath(oldNode);\n            var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\n            try {\n                fs.renameSync(oldPath, newPath)\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        unlink: (function (parent, name) {\n            var path = PATH.join2(NODEFS.realPath(parent), name);\n            try {\n                fs.unlinkSync(path)\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        rmdir: (function (parent, name) {\n            var path = PATH.join2(NODEFS.realPath(parent), name);\n            try {\n                fs.rmdirSync(path)\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        readdir: (function (node) {\n            var path = NODEFS.realPath(node);\n            try {\n                return fs.readdirSync(path)\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        symlink: (function (parent, newName, oldPath) {\n            var newPath = PATH.join2(NODEFS.realPath(parent), newName);\n            try {\n                fs.symlinkSync(oldPath, newPath)\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        readlink: (function (node) {\n            var path = NODEFS.realPath(node);\n            try {\n                path = fs.readlinkSync(path);\n                path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\n                return path\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        })\n    },\n    stream_ops: {\n        open: (function (stream) {\n            var path = NODEFS.realPath(stream.node);\n            try {\n                if (FS.isFile(stream.node.mode)) {\n                    stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags))\n                }\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        close: (function (stream) {\n            try {\n                if (FS.isFile(stream.node.mode) && stream.nfd) {\n                    fs.closeSync(stream.nfd)\n                }\n            } catch (e) {\n                if (!e.code) throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        read: (function (stream, buffer, offset, length, position) {\n            if (length === 0) return 0;\n            try {\n                return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position)\n            } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        write: (function (stream, buffer, offset, length, position) {\n            try {\n                return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position)\n            } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code])\n            }\n        }),\n        llseek: (function (stream, offset, whence) {\n            var position = offset;\n            if (whence === 1) {\n                position += stream.position\n            } else if (whence === 2) {\n                if (FS.isFile(stream.node.mode)) {\n                    try {\n                        var stat = fs.fstatSync(stream.nfd);\n                        position += stat.size\n                    } catch (e) {\n                        throw new FS.ErrnoError(ERRNO_CODES[e.code])\n                    }\n                }\n            }\n            if (position < 0) {\n                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n            }\n            return position\n        })\n    }\n};\nvar WORKERFS = {\n    DIR_MODE: 16895,\n    FILE_MODE: 33279,\n    reader: null,\n    mount: (function (mount) {\n        assert(ENVIRONMENT_IS_WORKER);\n        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync;\n        var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0);\n        var createdParents = {};\n\n        function ensureParent(path) {\n            var parts = path.split("/");\n            var parent = root;\n            for (var i = 0; i < parts.length - 1; i++) {\n                var curr = parts.slice(0, i + 1).join("/");\n                if (!createdParents[curr]) {\n                    createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0)\n                }\n                parent = createdParents[curr]\n            }\n            return parent\n        }\n\n        function base(path) {\n            var parts = path.split("/");\n            return parts[parts.length - 1]\n        }\n        Array.prototype.forEach.call(mount.opts["files"] || [], (function (file) {\n            WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate)\n        }));\n        (mount.opts["blobs"] || []).forEach((function (obj) {\n            WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"])\n        }));\n        (mount.opts["packages"] || []).forEach((function (pack) {\n            pack["metadata"].files.forEach((function (file) {\n                var name = file.filename.substr(1);\n                WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack["blob"].slice(file.start, file.end))\n            }))\n        }));\n        return root\n    }),\n    createNode: (function (parent, name, mode, dev, contents, mtime) {\n        var node = FS.createNode(parent, name, mode);\n        node.mode = mode;\n        node.node_ops = WORKERFS.node_ops;\n        node.stream_ops = WORKERFS.stream_ops;\n        node.timestamp = (mtime || new Date).getTime();\n        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n        if (mode === WORKERFS.FILE_MODE) {\n            node.size = contents.size;\n            node.contents = contents\n        } else {\n            node.size = 4096;\n            node.contents = {}\n        }\n        if (parent) {\n            parent.contents[name] = node\n        }\n        return node\n    }),\n    node_ops: {\n        getattr: (function (node) {\n            return {\n                dev: 1,\n                ino: undefined,\n                mode: node.mode,\n                nlink: 1,\n                uid: 0,\n                gid: 0,\n                rdev: undefined,\n                size: node.size,\n                atime: new Date(node.timestamp),\n                mtime: new Date(node.timestamp),\n                ctime: new Date(node.timestamp),\n                blksize: 4096,\n                blocks: Math.ceil(node.size / 4096)\n            }\n        }),\n        setattr: (function (node, attr) {\n            if (attr.mode !== undefined) {\n                node.mode = attr.mode\n            }\n            if (attr.timestamp !== undefined) {\n                node.timestamp = attr.timestamp\n            }\n        }),\n        lookup: (function (parent, name) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }),\n        mknod: (function (parent, name, mode, dev) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }),\n        rename: (function (oldNode, newDir, newName) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }),\n        unlink: (function (parent, name) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }),\n        rmdir: (function (parent, name) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }),\n        readdir: (function (node) {\n            var entries = [".", ".."];\n            for (var key in node.contents) {\n                if (!node.contents.hasOwnProperty(key)) {\n                    continue\n                }\n                entries.push(key)\n            }\n            return entries\n        }),\n        symlink: (function (parent, newName, oldPath) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }),\n        readlink: (function (node) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        })\n    },\n    stream_ops: {\n        read: (function (stream, buffer, offset, length, position) {\n            if (position >= stream.node.size) return 0;\n            var chunk = stream.node.contents.slice(position, position + length);\n            var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n            buffer.set(new Uint8Array(ab), offset);\n            return chunk.size\n        }),\n        write: (function (stream, buffer, offset, length, position) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO)\n        }),\n        llseek: (function (stream, offset, whence) {\n            var position = offset;\n            if (whence === 1) {\n                position += stream.position\n            } else if (whence === 2) {\n                if (FS.isFile(stream.node.mode)) {\n                    position += stream.node.size\n                }\n            }\n            if (position < 0) {\n                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n            }\n            return position\n        })\n    }\n};\nSTATICTOP += 16;\nSTATICTOP += 16;\nSTATICTOP += 16;\nvar FS = {\n    root: null,\n    mounts: [],\n    devices: {},\n    streams: [],\n    nextInode: 1,\n    nameTable: null,\n    currentPath: "/",\n    initialized: false,\n    ignorePermissions: true,\n    trackingDelegate: {},\n    tracking: {\n        openFlags: {\n            READ: 1,\n            WRITE: 2\n        }\n    },\n    ErrnoError: null,\n    genericErrors: {},\n    filesystems: null,\n    syncFSRequests: 0,\n    handleFSError: (function (e) {\n        if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();\n        return ___setErrNo(e.errno)\n    }),\n    lookupPath: (function (path, opts) {\n        path = PATH.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path) return {\n            path: "",\n            node: null\n        };\n        var defaults = {\n            follow_mount: true,\n            recurse_count: 0\n        };\n        for (var key in defaults) {\n            if (opts[key] === undefined) {\n                opts[key] = defaults[key]\n            }\n        }\n        if (opts.recurse_count > 8) {\n            throw new FS.ErrnoError(ERRNO_CODES.ELOOP)\n        }\n        var parts = PATH.normalizeArray(path.split("/").filter((function (p) {\n            return !!p\n        })), false);\n        var current = FS.root;\n        var current_path = "/";\n        for (var i = 0; i < parts.length; i++) {\n            var islast = i === parts.length - 1;\n            if (islast && opts.parent) {\n                break\n            }\n            current = FS.lookupNode(current, parts[i]);\n            current_path = PATH.join2(current_path, parts[i]);\n            if (FS.isMountpoint(current)) {\n                if (!islast || islast && opts.follow_mount) {\n                    current = current.mounted.root\n                }\n            }\n            if (!islast || opts.follow) {\n                var count = 0;\n                while (FS.isLink(current.mode)) {\n                    var link = FS.readlink(current_path);\n                    current_path = PATH.resolve(PATH.dirname(current_path), link);\n                    var lookup = FS.lookupPath(current_path, {\n                        recurse_count: opts.recurse_count\n                    });\n                    current = lookup.node;\n                    if (count++ > 40) {\n                        throw new FS.ErrnoError(ERRNO_CODES.ELOOP)\n                    }\n                }\n            }\n        }\n        return {\n            path: current_path,\n            node: current\n        }\n    }),\n    getPath: (function (node) {\n        var path;\n        while (true) {\n            if (FS.isRoot(node)) {\n                var mount = node.mount.mountpoint;\n                if (!path) return mount;\n                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path\n            }\n            path = path ? node.name + "/" + path : node.name;\n            node = node.parent\n        }\n    }),\n    hashName: (function (parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n            hash = (hash << 5) - hash + name.charCodeAt(i) | 0\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length\n    }),\n    hashAddNode: (function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node\n    }),\n    hashRemoveNode: (function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n            FS.nameTable[hash] = node.name_next\n        } else {\n            var current = FS.nameTable[hash];\n            while (current) {\n                if (current.name_next === node) {\n                    current.name_next = node.name_next;\n                    break\n                }\n                current = current.name_next\n            }\n        }\n    }),\n    lookupNode: (function (parent, name) {\n        var err = FS.mayLookup(parent);\n        if (err) {\n            throw new FS.ErrnoError(err, parent)\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n            var nodeName = node.name;\n            if (node.parent.id === parent.id && nodeName === name) {\n                return node\n            }\n        }\n        return FS.lookup(parent, name)\n    }),\n    createNode: (function (parent, name, mode, rdev) {\n        if (!FS.FSNode) {\n            FS.FSNode = (function (parent, name, mode, rdev) {\n                if (!parent) {\n                    parent = this\n                }\n                this.parent = parent;\n                this.mount = parent.mount;\n                this.mounted = null;\n                this.id = FS.nextInode++;\n                this.name = name;\n                this.mode = mode;\n                this.node_ops = {};\n                this.stream_ops = {};\n                this.rdev = rdev\n            });\n            FS.FSNode.prototype = {};\n            var readMode = 292 | 73;\n            var writeMode = 146;\n            Object.defineProperties(FS.FSNode.prototype, {\n                read: {\n                    get: (function () {\n                        return (this.mode & readMode) === readMode\n                    }),\n                    set: (function (val) {\n                        val ? this.mode |= readMode : this.mode &= ~readMode\n                    })\n                },\n                write: {\n                    get: (function () {\n                        return (this.mode & writeMode) === writeMode\n                    }),\n                    set: (function (val) {\n                        val ? this.mode |= writeMode : this.mode &= ~writeMode\n                    })\n                },\n                isFolder: {\n                    get: (function () {\n                        return FS.isDir(this.mode)\n                    })\n                },\n                isDevice: {\n                    get: (function () {\n                        return FS.isChrdev(this.mode)\n                    })\n                }\n            })\n        }\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node\n    }),\n    destroyNode: (function (node) {\n        FS.hashRemoveNode(node)\n    }),\n    isRoot: (function (node) {\n        return node === node.parent\n    }),\n    isMountpoint: (function (node) {\n        return !!node.mounted\n    }),\n    isFile: (function (mode) {\n        return (mode & 61440) === 32768\n    }),\n    isDir: (function (mode) {\n        return (mode & 61440) === 16384\n    }),\n    isLink: (function (mode) {\n        return (mode & 61440) === 40960\n    }),\n    isChrdev: (function (mode) {\n        return (mode & 61440) === 8192\n    }),\n    isBlkdev: (function (mode) {\n        return (mode & 61440) === 24576\n    }),\n    isFIFO: (function (mode) {\n        return (mode & 61440) === 4096\n    }),\n    isSocket: (function (mode) {\n        return (mode & 49152) === 49152\n    }),\n    flagModes: {\n        "r": 0,\n        "rs": 1052672,\n        "r+": 2,\n        "w": 577,\n        "wx": 705,\n        "xw": 705,\n        "w+": 578,\n        "wx+": 706,\n        "xw+": 706,\n        "a": 1089,\n        "ax": 1217,\n        "xa": 1217,\n        "a+": 1090,\n        "ax+": 1218,\n        "xa+": 1218\n    },\n    modeStringToFlags: (function (str) {\n        var flags = FS.flagModes[str];\n        if (typeof flags === "undefined") {\n            throw new Error("Unknown file open mode: " + str)\n        }\n        return flags\n    }),\n    flagsToPermissionString: (function (flag) {\n        var perms = ["r", "w", "rw"][flag & 3];\n        if (flag & 512) {\n            perms += "w"\n        }\n        return perms\n    }),\n    nodePermissions: (function (node, perms) {\n        if (FS.ignorePermissions) {\n            return 0\n        }\n        if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {\n            return ERRNO_CODES.EACCES\n        } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {\n            return ERRNO_CODES.EACCES\n        } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {\n            return ERRNO_CODES.EACCES\n        }\n        return 0\n    }),\n    mayLookup: (function (dir) {\n        var err = FS.nodePermissions(dir, "x");\n        if (err) return err;\n        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;\n        return 0\n    }),\n    mayCreate: (function (dir, name) {\n        try {\n            var node = FS.lookupNode(dir, name);\n            return ERRNO_CODES.EEXIST\n        } catch (e) { }\n        return FS.nodePermissions(dir, "wx")\n    }),\n    mayDelete: (function (dir, name, isdir) {\n        var node;\n        try {\n            node = FS.lookupNode(dir, name)\n        } catch (e) {\n            return e.errno\n        }\n        var err = FS.nodePermissions(dir, "wx");\n        if (err) {\n            return err\n        }\n        if (isdir) {\n            if (!FS.isDir(node.mode)) {\n                return ERRNO_CODES.ENOTDIR\n            }\n            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n                return ERRNO_CODES.EBUSY\n            }\n        } else {\n            if (FS.isDir(node.mode)) {\n                return ERRNO_CODES.EISDIR\n            }\n        }\n        return 0\n    }),\n    mayOpen: (function (node, flags) {\n        if (!node) {\n            return ERRNO_CODES.ENOENT\n        }\n        if (FS.isLink(node.mode)) {\n            return ERRNO_CODES.ELOOP\n        } else if (FS.isDir(node.mode)) {\n            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {\n                return ERRNO_CODES.EISDIR\n            }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags))\n    }),\n    MAX_OPEN_FDS: 4096,\n    nextfd: (function (fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n            if (!FS.streams[fd]) {\n                return fd\n            }\n        }\n        throw new FS.ErrnoError(ERRNO_CODES.EMFILE)\n    }),\n    getStream: (function (fd) {\n        return FS.streams[fd]\n    }),\n    createStream: (function (stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n            FS.FSStream = (function () { });\n            FS.FSStream.prototype = {};\n            Object.defineProperties(FS.FSStream.prototype, {\n                object: {\n                    get: (function () {\n                        return this.node\n                    }),\n                    set: (function (val) {\n                        this.node = val\n                    })\n                },\n                isRead: {\n                    get: (function () {\n                        return (this.flags & 2097155) !== 1\n                    })\n                },\n                isWrite: {\n                    get: (function () {\n                        return (this.flags & 2097155) !== 0\n                    })\n                },\n                isAppend: {\n                    get: (function () {\n                        return this.flags & 1024\n                    })\n                }\n            })\n        }\n        var newStream = new FS.FSStream;\n        for (var p in stream) {\n            newStream[p] = stream[p]\n        }\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream\n    }),\n    closeStream: (function (fd) {\n        FS.streams[fd] = null\n    }),\n    chrdev_stream_ops: {\n        open: (function (stream) {\n            var device = FS.getDevice(stream.node.rdev);\n            stream.stream_ops = device.stream_ops;\n            if (stream.stream_ops.open) {\n                stream.stream_ops.open(stream)\n            }\n        }),\n        llseek: (function () {\n            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\n        })\n    },\n    major: (function (dev) {\n        return dev >> 8\n    }),\n    minor: (function (dev) {\n        return dev & 255\n    }),\n    makedev: (function (ma, mi) {\n        return ma << 8 | mi\n    }),\n    registerDevice: (function (dev, ops) {\n        FS.devices[dev] = {\n            stream_ops: ops\n        }\n    }),\n    getDevice: (function (dev) {\n        return FS.devices[dev]\n    }),\n    getMounts: (function (mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n            var m = check.pop();\n            mounts.push(m);\n            check.push.apply(check, m.mounts)\n        }\n        return mounts\n    }),\n    syncfs: (function (populate, callback) {\n        if (typeof populate === "function") {\n            callback = populate;\n            populate = false\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n            console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work")\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(err) {\n            assert(FS.syncFSRequests > 0);\n            FS.syncFSRequests--;\n            return callback(err)\n        }\n\n        function done(err) {\n            if (err) {\n                if (!done.errored) {\n                    done.errored = true;\n                    return doCallback(err)\n                }\n                return\n            }\n            if (++completed >= mounts.length) {\n                doCallback(null)\n            }\n        }\n        mounts.forEach((function (mount) {\n            if (!mount.type.syncfs) {\n                return done(null)\n            }\n            mount.type.syncfs(mount, populate, done)\n        }))\n    }),\n    mount: (function (type, opts, mountpoint) {\n        var root = mountpoint === "/";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\n        } else if (!root && !pseudo) {\n            var lookup = FS.lookupPath(mountpoint, {\n                follow_mount: false\n            });\n            mountpoint = lookup.path;\n            node = lookup.node;\n            if (FS.isMountpoint(node)) {\n                throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\n            }\n            if (!FS.isDir(node.mode)) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\n            }\n        }\n        var mount = {\n            type: type,\n            opts: opts,\n            mountpoint: mountpoint,\n            mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n            FS.root = mountRoot\n        } else if (node) {\n            node.mounted = mount;\n            if (node.mount) {\n                node.mount.mounts.push(mount)\n            }\n        }\n        return mountRoot\n    }),\n    unmount: (function (mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n        });\n        if (!FS.isMountpoint(lookup.node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach((function (hash) {\n            var current = FS.nameTable[hash];\n            while (current) {\n                var next = current.name_next;\n                if (mounts.indexOf(current.mount) !== -1) {\n                    FS.destroyNode(current)\n                }\n                current = next\n            }\n        }));\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1)\n    }),\n    lookup: (function (parent, name) {\n        return parent.node_ops.lookup(parent, name)\n    }),\n    mknod: (function (path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n            parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === "." || name === "..") {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        var err = FS.mayCreate(parent, name);\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        if (!parent.node_ops.mknod) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev)\n    }),\n    create: (function (path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0)\n    }),\n    mkdir: (function (path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0)\n    }),\n    mkdirTree: (function (path, mode) {\n        var dirs = path.split("/");\n        var d = "";\n        for (var i = 0; i < dirs.length; ++i) {\n            if (!dirs[i]) continue;\n            d += "/" + dirs[i];\n            try {\n                FS.mkdir(d, mode)\n            } catch (e) {\n                if (e.errno != ERRNO_CODES.EEXIST) throw e\n            }\n        }\n    }),\n    mkdev: (function (path, mode, dev) {\n        if (typeof dev === "undefined") {\n            dev = mode;\n            mode = 438\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev)\n    }),\n    symlink: (function (oldpath, newpath) {\n        if (!PATH.resolve(oldpath)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        var lookup = FS.lookupPath(newpath, {\n            parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        var newname = PATH.basename(newpath);\n        var err = FS.mayCreate(parent, newname);\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        if (!parent.node_ops.symlink) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath)\n    }),\n    rename: (function (old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        try {\n            lookup = FS.lookupPath(old_path, {\n                parent: true\n            });\n            old_dir = lookup.node;\n            lookup = FS.lookupPath(new_path, {\n                parent: true\n            });\n            new_dir = lookup.node\n        } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\n        }\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        if (old_dir.mount !== new_dir.mount) {\n            throw new FS.ErrnoError(ERRNO_CODES.EXDEV)\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== ".") {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        relative = PATH.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== ".") {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)\n        }\n        var new_node;\n        try {\n            new_node = FS.lookupNode(new_dir, new_name)\n        } catch (e) { }\n        if (old_node === new_node) {\n            return\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var err = FS.mayDelete(old_dir, old_name, isdir);\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        if (!old_dir.node_ops.rename) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\n        }\n        if (new_dir !== old_dir) {\n            err = FS.nodePermissions(old_dir, "w");\n            if (err) {\n                throw new FS.ErrnoError(err)\n            }\n        }\n        try {\n            if (FS.trackingDelegate["willMovePath"]) {\n                FS.trackingDelegate["willMovePath"](old_path, new_path)\n            }\n        } catch (e) {\n            console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message)\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n            old_dir.node_ops.rename(old_node, new_dir, new_name)\n        } catch (e) {\n            throw e\n        } finally {\n            FS.hashAddNode(old_node)\n        }\n        try {\n            if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path)\n        } catch (e) {\n            console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message)\n        }\n    }),\n    rmdir: (function (path) {\n        var lookup = FS.lookupPath(path, {\n            parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, true);\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        if (!parent.node_ops.rmdir) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\n        }\n        try {\n            if (FS.trackingDelegate["willDeletePath"]) {\n                FS.trackingDelegate["willDeletePath"](path)\n            }\n        } catch (e) {\n            console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message)\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n        try {\n            if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path)\n        } catch (e) {\n            console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message)\n        }\n    }),\n    readdir: (function (path) {\n        var lookup = FS.lookupPath(path, {\n            follow: true\n        });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\n        }\n        return node.node_ops.readdir(node)\n    }),\n    unlink: (function (path) {\n        var lookup = FS.lookupPath(path, {\n            parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, false);\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        if (!parent.node_ops.unlink) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)\n        }\n        try {\n            if (FS.trackingDelegate["willDeletePath"]) {\n                FS.trackingDelegate["willDeletePath"](path)\n            }\n        } catch (e) {\n            console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message)\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n        try {\n            if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path)\n        } catch (e) {\n            console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message)\n        }\n    }),\n    readlink: (function (path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        if (!link.node_ops.readlink) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))\n    }),\n    stat: (function (path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n        });\n        var node = lookup.node;\n        if (!node) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        if (!node.node_ops.getattr) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        return node.node_ops.getattr(node)\n    }),\n    lstat: (function (path) {\n        return FS.stat(path, true)\n    }),\n    chmod: (function (path, mode, dontFollow) {\n        var node;\n        if (typeof path === "string") {\n            var lookup = FS.lookupPath(path, {\n                follow: !dontFollow\n            });\n            node = lookup.node\n        } else {\n            node = path\n        }\n        if (!node.node_ops.setattr) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        node.node_ops.setattr(node, {\n            mode: mode & 4095 | node.mode & ~4095,\n            timestamp: Date.now()\n        })\n    }),\n    lchmod: (function (path, mode) {\n        FS.chmod(path, mode, true)\n    }),\n    fchmod: (function (fd, mode) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        FS.chmod(stream.node, mode)\n    }),\n    chown: (function (path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path === "string") {\n            var lookup = FS.lookupPath(path, {\n                follow: !dontFollow\n            });\n            node = lookup.node\n        } else {\n            node = path\n        }\n        if (!node.node_ops.setattr) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        node.node_ops.setattr(node, {\n            timestamp: Date.now()\n        })\n    }),\n    lchown: (function (path, uid, gid) {\n        FS.chown(path, uid, gid, true)\n    }),\n    fchown: (function (fd, uid, gid) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        FS.chown(stream.node, uid, gid)\n    }),\n    truncate: (function (path, len) {\n        if (len < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        var node;\n        if (typeof path === "string") {\n            var lookup = FS.lookupPath(path, {\n                follow: true\n            });\n            node = lookup.node\n        } else {\n            node = path\n        }\n        if (!node.node_ops.setattr) {\n            throw new FS.ErrnoError(ERRNO_CODES.EPERM)\n        }\n        if (FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EISDIR)\n        }\n        if (!FS.isFile(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        var err = FS.nodePermissions(node, "w");\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        node.node_ops.setattr(node, {\n            size: len,\n            timestamp: Date.now()\n        })\n    }),\n    ftruncate: (function (fd, len) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if ((stream.flags & 2097155) === 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        FS.truncate(stream.node, len)\n    }),\n    utime: (function (path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n            follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n            timestamp: Math.max(atime, mtime)\n        })\n    }),\n    open: (function (path, flags, mode, fd_start, fd_end) {\n        if (path === "") {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === "undefined" ? 438 : mode;\n        if (flags & 64) {\n            mode = mode & 4095 | 32768\n        } else {\n            mode = 0\n        }\n        var node;\n        if (typeof path === "object") {\n            node = path\n        } else {\n            path = PATH.normalize(path);\n            try {\n                var lookup = FS.lookupPath(path, {\n                    follow: !(flags & 131072)\n                });\n                node = lookup.node\n            } catch (e) { }\n        }\n        var created = false;\n        if (flags & 64) {\n            if (node) {\n                if (flags & 128) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EEXIST)\n                }\n            } else {\n                node = FS.mknod(path, mode, 0);\n                created = true\n            }\n        }\n        if (!node) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        if (FS.isChrdev(node.mode)) {\n            flags &= ~512\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\n        }\n        if (!created) {\n            var err = FS.mayOpen(node, flags);\n            if (err) {\n                throw new FS.ErrnoError(err)\n            }\n        }\n        if (flags & 512) {\n            FS.truncate(node, 0)\n        }\n        flags &= ~(128 | 512);\n        var stream = FS.createStream({\n            node: node,\n            path: FS.getPath(node),\n            flags: flags,\n            seekable: true,\n            position: 0,\n            stream_ops: node.stream_ops,\n            ungotten: [],\n            error: false\n        }, fd_start, fd_end);\n        if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream)\n        }\n        if (Module["logReadFiles"] && !(flags & 1)) {\n            if (!FS.readFiles) FS.readFiles = {};\n            if (!(path in FS.readFiles)) {\n                FS.readFiles[path] = 1;\n                err("read file: " + path)\n            }\n        }\n        try {\n            if (FS.trackingDelegate["onOpenFile"]) {\n                var trackingFlags = 0;\n                if ((flags & 2097155) !== 1) {\n                    trackingFlags |= FS.tracking.openFlags.READ\n                }\n                if ((flags & 2097155) !== 0) {\n                    trackingFlags |= FS.tracking.openFlags.WRITE\n                }\n                FS.trackingDelegate["onOpenFile"](path, trackingFlags)\n            }\n        } catch (e) {\n            console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message)\n        }\n        return stream\n    }),\n    close: (function (stream) {\n        if (FS.isClosed(stream)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n            if (stream.stream_ops.close) {\n                stream.stream_ops.close(stream)\n            }\n        } catch (e) {\n            throw e\n        } finally {\n            FS.closeStream(stream.fd)\n        }\n        stream.fd = null\n    }),\n    isClosed: (function (stream) {\n        return stream.fd === null\n    }),\n    llseek: (function (stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position\n    }),\n    read: (function (stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        if (FS.isClosed(stream)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if ((stream.flags & 2097155) === 1) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if (FS.isDir(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EISDIR)\n        }\n        if (!stream.stream_ops.read) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        var seeking = typeof position !== "undefined";\n        if (!seeking) {\n            position = stream.position\n        } else if (!stream.seekable) {\n            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead\n    }),\n    write: (function (stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        if (FS.isClosed(stream)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if ((stream.flags & 2097155) === 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if (FS.isDir(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EISDIR)\n        }\n        if (!stream.stream_ops.write) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        if (stream.flags & 1024) {\n            FS.llseek(stream, 0, 2)\n        }\n        var seeking = typeof position !== "undefined";\n        if (!seeking) {\n            position = stream.position\n        } else if (!stream.seekable) {\n            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        try {\n            if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path)\n        } catch (e) {\n            console.log("FS.trackingDelegate['onWriteToFile']('" + path + "') threw an exception: " + e.message)\n        }\n        return bytesWritten\n    }),\n    allocate: (function (stream, offset, length) {\n        if (FS.isClosed(stream)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if (offset < 0 || length <= 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        }\n        if ((stream.flags & 2097155) === 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBADF)\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n        }\n        if (!stream.stream_ops.allocate) {\n            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)\n        }\n        stream.stream_ops.allocate(stream, offset, length)\n    }),\n    mmap: (function (stream, buffer, offset, length, position, prot, flags) {\n        if ((stream.flags & 2097155) === 1) {\n            throw new FS.ErrnoError(ERRNO_CODES.EACCES)\n        }\n        if (!stream.stream_ops.mmap) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n        }\n        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags)\n    }),\n    msync: (function (stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n            return 0\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)\n    }),\n    munmap: (function (stream) {\n        return 0\n    }),\n    ioctl: (function (stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg)\n    }),\n    readFile: (function (path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || "r";\n        opts.encoding = opts.encoding || "binary";\n        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {\n            throw new Error('Invalid encoding type "' + opts.encoding + '"')\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === "utf8") {\n            ret = UTF8ArrayToString(buf, 0)\n        } else if (opts.encoding === "binary") {\n            ret = buf\n        }\n        FS.close(stream);\n        return ret\n    }),\n    writeFile: (function (path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || "w";\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data === "string") {\n            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n            FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn)\n        } else if (ArrayBuffer.isView(data)) {\n            FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn)\n        } else {\n            throw new Error("Unsupported data type")\n        }\n        FS.close(stream)\n    }),\n    cwd: (function () {\n        return FS.currentPath\n    }),\n    chdir: (function (path) {\n        var lookup = FS.lookupPath(path, {\n            follow: true\n        });\n        if (lookup.node === null) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)\n        }\n        var err = FS.nodePermissions(lookup.node, "x");\n        if (err) {\n            throw new FS.ErrnoError(err)\n        }\n        FS.currentPath = lookup.path\n    }),\n    createDefaultDirectories: (function () {\n        FS.mkdir("/tmp");\n        FS.mkdir("/home");\n        FS.mkdir("/home/web_user")\n    }),\n    createDefaultDevices: (function () {\n        FS.mkdir("/dev");\n        FS.registerDevice(FS.makedev(1, 3), {\n            read: (function () {\n                return 0\n            }),\n            write: (function (stream, buffer, offset, length, pos) {\n                return length\n            })\n        });\n        FS.mkdev("/dev/null", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev("/dev/tty", FS.makedev(5, 0));\n        FS.mkdev("/dev/tty1", FS.makedev(6, 0));\n        var random_device;\n        if (typeof crypto !== "undefined") {\n            var randomBuffer = new Uint8Array(1);\n            random_device = (function () {\n                crypto.getRandomValues(randomBuffer);\n                return randomBuffer[0]\n            })\n        } else if (ENVIRONMENT_IS_NODE) {\n            random_device = (function () {\n                return require("crypto")["randomBytes"](1)[0]\n            })\n        } else {\n            random_device = (function () {\n                abort("random_device")\n            })\n        }\n        FS.createDevice("/dev", "random", random_device);\n        FS.createDevice("/dev", "urandom", random_device);\n        FS.mkdir("/dev/shm");\n        FS.mkdir("/dev/shm/tmp")\n    }),\n    createSpecialDirectories: (function () {\n        FS.mkdir("/proc");\n        FS.mkdir("/proc/self");\n        FS.mkdir("/proc/self/fd");\n        FS.mount({\n            mount: (function () {\n                var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);\n                node.node_ops = {\n                    lookup: (function (parent, name) {\n                        var fd = +name;\n                        var stream = FS.getStream(fd);\n                        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n                        var ret = {\n                            parent: null,\n                            mount: {\n                                mountpoint: "fake"\n                            },\n                            node_ops: {\n                                readlink: (function () {\n                                    return stream.path\n                                })\n                            }\n                        };\n                        ret.parent = ret;\n                        return ret\n                    })\n                };\n                return node\n            })\n        }, {}, "/proc/self/fd")\n    }),\n    createStandardStreams: (function () {\n        if (Module["stdin"]) {\n            FS.createDevice("/dev", "stdin", Module["stdin"])\n        } else {\n            FS.symlink("/dev/tty", "/dev/stdin")\n        }\n        if (Module["stdout"]) {\n            FS.createDevice("/dev", "stdout", null, Module["stdout"])\n        } else {\n            FS.symlink("/dev/tty", "/dev/stdout")\n        }\n        if (Module["stderr"]) {\n            FS.createDevice("/dev", "stderr", null, Module["stderr"])\n        } else {\n            FS.symlink("/dev/tty1", "/dev/stderr")\n        }\n        var stdin = FS.open("/dev/stdin", "r");\n        assert(stdin.fd === 0, "invalid handle for stdin (" + stdin.fd + ")");\n        var stdout = FS.open("/dev/stdout", "w");\n        assert(stdout.fd === 1, "invalid handle for stdout (" + stdout.fd + ")");\n        var stderr = FS.open("/dev/stderr", "w");\n        assert(stderr.fd === 2, "invalid handle for stderr (" + stderr.fd + ")")\n    }),\n    ensureErrnoError: (function () {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n            this.node = node;\n            this.setErrno = (function (errno) {\n                this.errno = errno;\n                for (var key in ERRNO_CODES) {\n                    if (ERRNO_CODES[key] === errno) {\n                        this.code = key;\n                        break\n                    }\n                }\n            });\n            this.setErrno(errno);\n            this.message = ERRNO_MESSAGES[errno];\n            if (this.stack) Object.defineProperty(this, "stack", {\n                value: (new Error).stack,\n                writable: true\n            })\n        };\n        FS.ErrnoError.prototype = new Error;\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [ERRNO_CODES.ENOENT].forEach((function (code) {\n            FS.genericErrors[code] = new FS.ErrnoError(code);\n            FS.genericErrors[code].stack = "<generic error, no stack>"\n        }))\n    }),\n    staticInit: (function () {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, "/");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n            "MEMFS": MEMFS,\n            "IDBFS": IDBFS,\n            "NODEFS": NODEFS,\n            "WORKERFS": WORKERFS\n        }\n    }),\n    init: (function (input, output, error) {\n        assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module["stdin"] = input || Module["stdin"];\n        Module["stdout"] = output || Module["stdout"];\n        Module["stderr"] = error || Module["stderr"];\n        FS.createStandardStreams()\n    }),\n    quit: (function () {\n        FS.init.initialized = false;\n        var fflush = Module["_fflush"];\n        if (fflush) fflush(0);\n        for (var i = 0; i < FS.streams.length; i++) {\n            var stream = FS.streams[i];\n            if (!stream) {\n                continue\n            }\n            FS.close(stream)\n        }\n    }),\n    getMode: (function (canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode\n    }),\n    joinPath: (function (parts, forceRelative) {\n        var path = PATH.join.apply(null, parts);\n        if (forceRelative && path[0] == "/") path = path.substr(1);\n        return path\n    }),\n    absolutePath: (function (relative, base) {\n        return PATH.resolve(base, relative)\n    }),\n    standardizePath: (function (path) {\n        return PATH.normalize(path)\n    }),\n    findObject: (function (path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (ret.exists) {\n            return ret.object\n        } else {\n            ___setErrNo(ret.error);\n            return null\n        }\n    }),\n    analyzePath: (function (path, dontResolveLastLink) {\n        try {\n            var lookup = FS.lookupPath(path, {\n                follow: !dontResolveLastLink\n            });\n            path = lookup.path\n        } catch (e) { }\n        var ret = {\n            isRoot: false,\n            exists: false,\n            error: 0,\n            name: null,\n            path: null,\n            object: null,\n            parentExists: false,\n            parentPath: null,\n            parentObject: null\n        };\n        try {\n            var lookup = FS.lookupPath(path, {\n                parent: true\n            });\n            ret.parentExists = true;\n            ret.parentPath = lookup.path;\n            ret.parentObject = lookup.node;\n            ret.name = PATH.basename(path);\n            lookup = FS.lookupPath(path, {\n                follow: !dontResolveLastLink\n            });\n            ret.exists = true;\n            ret.path = lookup.path;\n            ret.object = lookup.node;\n            ret.name = lookup.node.name;\n            ret.isRoot = lookup.path === "/"\n        } catch (e) {\n            ret.error = e.errno\n        }\n        return ret\n    }),\n    createFolder: (function (parent, name, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.mkdir(path, mode)\n    }),\n    createPath: (function (parent, path, canRead, canWrite) {\n        parent = typeof parent === "string" ? parent : FS.getPath(parent);\n        var parts = path.split("/").reverse();\n        while (parts.length) {\n            var part = parts.pop();\n            if (!part) continue;\n            var current = PATH.join2(parent, part);\n            try {\n                FS.mkdir(current)\n            } catch (e) { }\n            parent = current\n        }\n        return current\n    }),\n    createFile: (function (parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode)\n    }),\n    createDataFile: (function (parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n            if (typeof data === "string") {\n                var arr = new Array(data.length);\n                for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n                data = arr\n            }\n            FS.chmod(node, mode | 146);\n            var stream = FS.open(node, "w");\n            FS.write(stream, data, 0, data.length, 0, canOwn);\n            FS.close(stream);\n            FS.chmod(node, mode)\n        }\n        return node\n    }),\n    createDevice: (function (parent, name, input, output) {\n        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n            open: (function (stream) {\n                stream.seekable = false\n            }),\n            close: (function (stream) {\n                if (output && output.buffer && output.buffer.length) {\n                    output(10)\n                }\n            }),\n            read: (function (stream, buffer, offset, length, pos) {\n                var bytesRead = 0;\n                for (var i = 0; i < length; i++) {\n                    var result;\n                    try {\n                        result = input()\n                    } catch (e) {\n                        throw new FS.ErrnoError(ERRNO_CODES.EIO)\n                    }\n                    if (result === undefined && bytesRead === 0) {\n                        throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)\n                    }\n                    if (result === null || result === undefined) break;\n                    bytesRead++;\n                    buffer[offset + i] = result\n                }\n                if (bytesRead) {\n                    stream.node.timestamp = Date.now()\n                }\n                return bytesRead\n            }),\n            write: (function (stream, buffer, offset, length, pos) {\n                for (var i = 0; i < length; i++) {\n                    try {\n                        output(buffer[offset + i])\n                    } catch (e) {\n                        throw new FS.ErrnoError(ERRNO_CODES.EIO)\n                    }\n                }\n                if (length) {\n                    stream.node.timestamp = Date.now()\n                }\n                return i\n            })\n        });\n        return FS.mkdev(path, mode, dev)\n    }),\n    createLink: (function (parent, name, target, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n        return FS.symlink(target, path)\n    }),\n    forceLoadFile: (function (obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        var success = true;\n        if (typeof XMLHttpRequest !== "undefined") {\n            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")\n        } else if (Module["read"]) {\n            try {\n                obj.contents = intArrayFromString(Module["read"](obj.url), true);\n                obj.usedBytes = obj.contents.length\n            } catch (e) {\n                success = false\n            }\n        } else {\n            throw new Error("Cannot load without read() or XMLHttpRequest.")\n        }\n        if (!success) ___setErrNo(ERRNO_CODES.EIO);\n        return success\n    }),\n    createLazyFile: (function (parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n            this.lengthKnown = false;\n            this.chunks = []\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n            if (idx > this.length - 1 || idx < 0) {\n                return undefined\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = idx / this.chunkSize | 0;\n            return this.getter(chunkNum)[chunkOffset]\n        };\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n            this.getter = getter\n        };\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n            var xhr = new XMLHttpRequest;\n            xhr.open("HEAD", url, false);\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);\n            var datalength = Number(xhr.getResponseHeader("Content-length"));\n            var header;\n            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";\n            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";\n            var chunkSize = 1024 * 1024;\n            if (!hasByteServing) chunkSize = datalength;\n            var doXHR = (function (from, to) {\n                if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");\n                if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");\n                var xhr = new XMLHttpRequest;\n                xhr.open("GET", url, false);\n                if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);\n                if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";\n                if (xhr.overrideMimeType) {\n                    xhr.overrideMimeType("text/plain; charset=x-user-defined")\n                }\n                xhr.send(null);\n                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);\n                if (xhr.response !== undefined) {\n                    return new Uint8Array(xhr.response || [])\n                } else {\n                    return intArrayFromString(xhr.responseText || "", true)\n                }\n            });\n            var lazyArray = this;\n            lazyArray.setDataGetter((function (chunkNum) {\n                var start = chunkNum * chunkSize;\n                var end = (chunkNum + 1) * chunkSize - 1;\n                end = Math.min(end, datalength - 1);\n                if (typeof lazyArray.chunks[chunkNum] === "undefined") {\n                    lazyArray.chunks[chunkNum] = doXHR(start, end)\n                }\n                if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");\n                return lazyArray.chunks[chunkNum]\n            }));\n            if (usesGzip || !datalength) {\n                chunkSize = datalength = 1;\n                datalength = this.getter(0).length;\n                chunkSize = datalength;\n                console.log("LazyFiles on gzip forces download of the whole file when length is accessed")\n            }\n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true\n        };\n        if (typeof XMLHttpRequest !== "undefined") {\n            if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";\n            var lazyArray = new LazyUint8Array;\n            Object.defineProperties(lazyArray, {\n                length: {\n                    get: (function () {\n                        if (!this.lengthKnown) {\n                            this.cacheLength()\n                        }\n                        return this._length\n                    })\n                },\n                chunkSize: {\n                    get: (function () {\n                        if (!this.lengthKnown) {\n                            this.cacheLength()\n                        }\n                        return this._chunkSize\n                    })\n                }\n            });\n            var properties = {\n                isDevice: false,\n                contents: lazyArray\n            }\n        } else {\n            var properties = {\n                isDevice: false,\n                url: url\n            }\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n            node.contents = properties.contents\n        } else if (properties.url) {\n            node.contents = null;\n            node.url = properties.url\n        }\n        Object.defineProperties(node, {\n            usedBytes: {\n                get: (function () {\n                    return this.contents.length\n                })\n            }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((function (key) {\n            var fn = node.stream_ops[key];\n            stream_ops[key] = function forceLoadLazyFile() {\n                if (!FS.forceLoadFile(node)) {\n                    throw new FS.ErrnoError(ERRNO_CODES.EIO)\n                }\n                return fn.apply(null, arguments)\n            }\n        }));\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n            if (!FS.forceLoadFile(node)) {\n                throw new FS.ErrnoError(ERRNO_CODES.EIO)\n            }\n            var contents = stream.node.contents;\n            if (position >= contents.length) return 0;\n            var size = Math.min(contents.length - position, length);\n            assert(size >= 0);\n            if (contents.slice) {\n                for (var i = 0; i < size; i++) {\n                    buffer[offset + i] = contents[position + i]\n                }\n            } else {\n                for (var i = 0; i < size; i++) {\n                    buffer[offset + i] = contents.get(position + i)\n                }\n            }\n            return size\n        };\n        node.stream_ops = stream_ops;\n        return node\n    }),\n    createPreloadedFile: (function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency("cp " + fullname);\n\n        function processData(byteArray) {\n            function finish(byteArray) {\n                if (preFinish) preFinish();\n                if (!dontCreateFile) {\n                    FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn)\n                }\n                if (onload) onload();\n                removeRunDependency(dep)\n            }\n            var handled = false;\n            Module["preloadPlugins"].forEach((function (plugin) {\n                if (handled) return;\n                if (plugin["canHandle"](fullname)) {\n                    plugin["handle"](byteArray, fullname, finish, (function () {\n                        if (onerror) onerror();\n                        removeRunDependency(dep)\n                    }));\n                    handled = true\n                }\n            }));\n            if (!handled) finish(byteArray)\n        }\n        addRunDependency(dep);\n        if (typeof url == "string") {\n            Browser.asyncLoad(url, (function (byteArray) {\n                processData(byteArray)\n            }), onerror)\n        } else {\n            processData(url)\n        }\n    }),\n    indexedDB: (function () {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB\n    }),\n    DB_NAME: (function () {\n        return "EM_FS_" + window.location.pathname\n    }),\n    DB_VERSION: 20,\n    DB_STORE_NAME: "FILE_DATA",\n    saveFilesToDB: (function (paths, onload, onerror) {\n        onload = onload || (function () { });\n        onerror = onerror || (function () { });\n        var indexedDB = FS.indexedDB();\n        try {\n            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)\n        } catch (e) {\n            return onerror(e)\n        }\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n            console.log("creating db");\n            var db = openRequest.result;\n            db.createObjectStore(FS.DB_STORE_NAME)\n        };\n        openRequest.onsuccess = function openRequest_onsuccess() {\n            var db = openRequest.result;\n            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");\n            var files = transaction.objectStore(FS.DB_STORE_NAME);\n            var ok = 0,\n                fail = 0,\n                total = paths.length;\n\n            function finish() {\n                if (fail == 0) onload();\n                else onerror()\n            }\n            paths.forEach((function (path) {\n                var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n                putRequest.onsuccess = function putRequest_onsuccess() {\n                    ok++;\n                    if (ok + fail == total) finish()\n                };\n                putRequest.onerror = function putRequest_onerror() {\n                    fail++;\n                    if (ok + fail == total) finish()\n                }\n            }));\n            transaction.onerror = onerror\n        };\n        openRequest.onerror = onerror\n    }),\n    loadFilesFromDB: (function (paths, onload, onerror) {\n        onload = onload || (function () { });\n        onerror = onerror || (function () { });\n        var indexedDB = FS.indexedDB();\n        try {\n            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)\n        } catch (e) {\n            return onerror(e)\n        }\n        openRequest.onupgradeneeded = onerror;\n        openRequest.onsuccess = function openRequest_onsuccess() {\n            var db = openRequest.result;\n            try {\n                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly")\n            } catch (e) {\n                onerror(e);\n                return\n            }\n            var files = transaction.objectStore(FS.DB_STORE_NAME);\n            var ok = 0,\n                fail = 0,\n                total = paths.length;\n\n            function finish() {\n                if (fail == 0) onload();\n                else onerror()\n            }\n            paths.forEach((function (path) {\n                var getRequest = files.get(path);\n                getRequest.onsuccess = function getRequest_onsuccess() {\n                    if (FS.analyzePath(path).exists) {\n                        FS.unlink(path)\n                    }\n                    FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n                    ok++;\n                    if (ok + fail == total) finish()\n                };\n                getRequest.onerror = function getRequest_onerror() {\n                    fail++;\n                    if (ok + fail == total) finish()\n                }\n            }));\n            transaction.onerror = onerror\n        };\n        openRequest.onerror = onerror\n    })\n};\nvar SYSCALLS = {\n    DEFAULT_POLLMASK: 5,\n    mappings: {},\n    umask: 511,\n    calculateAt: (function (dirfd, path) {\n        if (path[0] !== "/") {\n            var dir;\n            if (dirfd === -100) {\n                dir = FS.cwd()\n            } else {\n                var dirstream = FS.getStream(dirfd);\n                if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n                dir = dirstream.path\n            }\n            path = PATH.join2(dir, path)\n        }\n        return path\n    }),\n    doStat: (function (func, path, buf) {\n        try {\n            var stat = func(path)\n        } catch (e) {\n            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n                return -ERRNO_CODES.ENOTDIR\n            }\n            throw e\n        }\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        HEAP32[buf + 36 >> 2] = stat.size;\n        HEAP32[buf + 40 >> 2] = 4096;\n        HEAP32[buf + 44 >> 2] = stat.blocks;\n        HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 52 >> 2] = 0;\n        HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ino;\n        return 0\n    }),\n    doMsync: (function (addr, stream, len, flags) {\n        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\n        FS.msync(stream, buffer, 0, len, flags)\n    }),\n    doMkdir: (function (path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0\n    }),\n    doMknod: (function (path, mode, dev) {\n        switch (mode & 61440) {\n            case 32768:\n            case 8192:\n            case 24576:\n            case 4096:\n            case 49152:\n                break;\n            default:\n                return -ERRNO_CODES.EINVAL\n        }\n        FS.mknod(path, mode, dev);\n        return 0\n    }),\n    doReadlink: (function (path, buf, bufsize) {\n        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len\n    }),\n    doAccess: (function (path, amode) {\n        if (amode & ~7) {\n            return -ERRNO_CODES.EINVAL\n        }\n        var node;\n        var lookup = FS.lookupPath(path, {\n            follow: true\n        });\n        node = lookup.node;\n        var perms = "";\n        if (amode & 4) perms += "r";\n        if (amode & 2) perms += "w";\n        if (amode & 1) perms += "x";\n        if (perms && FS.nodePermissions(node, perms)) {\n            return -ERRNO_CODES.EACCES\n        }\n        return 0\n    }),\n    doDup: (function (path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd\n    }),\n    doReadv: (function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n            var ptr = HEAP32[iov + i * 8 >> 2];\n            var len = HEAP32[iov + (i * 8 + 4) >> 2];\n            var curr = FS.read(stream, HEAP8, ptr, len, offset);\n            if (curr < 0) return -1;\n            ret += curr;\n            if (curr < len) break\n        }\n        return ret\n    }),\n    doWritev: (function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n            var ptr = HEAP32[iov + i * 8 >> 2];\n            var len = HEAP32[iov + (i * 8 + 4) >> 2];\n            var curr = FS.write(stream, HEAP8, ptr, len, offset);\n            if (curr < 0) return -1;\n            ret += curr\n        }\n        return ret\n    }),\n    varargs: 0,\n    get: (function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret\n    }),\n    getStr: (function () {\n        var ret = Pointer_stringify(SYSCALLS.get());\n        return ret\n    }),\n    getStreamFromFD: (function () {\n        var stream = FS.getStream(SYSCALLS.get());\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return stream\n    }),\n    getSocketFromFD: (function () {\n        var socket = SOCKFS.getSocket(SYSCALLS.get());\n        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return socket\n    }),\n    getSocketAddress: (function (allowNull) {\n        var addrp = SYSCALLS.get(),\n            addrlen = SYSCALLS.get();\n        if (allowNull && addrp === 0) return null;\n        var info = __read_sockaddr(addrp, addrlen);\n        if (info.errno) throw new FS.ErrnoError(info.errno);\n        info.addr = DNS.lookup_addr(info.addr) || info.addr;\n        return info\n    }),\n    get64: (function () {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low\n    }),\n    getZero: (function () {\n        assert(SYSCALLS.get() === 0)\n    })\n};\n\nfunction ___syscall140(which, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            offset_high = SYSCALLS.get(),\n            offset_low = SYSCALLS.get(),\n            result = SYSCALLS.get(),\n            whence = SYSCALLS.get();\n        var offset = offset_low;\n        FS.llseek(stream, offset, whence);\n        HEAP32[result >> 2] = stream.position;\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0\n    } catch (e) {\n        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno\n    }\n}\n\nfunction ___syscall145(which, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        return SYSCALLS.doReadv(stream, iov, iovcnt)\n    } catch (e) {\n        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno\n    }\n}\n\nfunction ___syscall146(which, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        return SYSCALLS.doWritev(stream, iov, iovcnt)\n    } catch (e) {\n        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno\n    }\n}\n\nfunction ___syscall54(which, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            op = SYSCALLS.get();\n        switch (op) {\n            case 21509:\n            case 21505:\n                {\n                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                    return 0\n                };\n            case 21510:\n            case 21511:\n            case 21512:\n            case 21506:\n            case 21507:\n            case 21508:\n                {\n                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                    return 0\n                };\n            case 21519:\n                {\n                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                    var argp = SYSCALLS.get(); HEAP32[argp >> 2] = 0;\n                    return 0\n                };\n            case 21520:\n                {\n                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                    return -ERRNO_CODES.EINVAL\n                };\n            case 21531:\n                {\n                    var argp = SYSCALLS.get();\n                    return FS.ioctl(stream, op, argp)\n                };\n            case 21523:\n                {\n                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                    return 0\n                };\n            case 21524:\n                {\n                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n                    return 0\n                };\n            default:\n                abort("bad ioctl syscall " + op)\n        }\n    } catch (e) {\n        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno\n    }\n}\n\nfunction ___syscall6(which, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n        var stream = SYSCALLS.getStreamFromFD();\n        FS.close(stream);\n        return 0\n    } catch (e) {\n        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno\n    }\n}\n\nfunction ___syscall91(which, varargs) {\n    SYSCALLS.varargs = varargs;\n    try {\n        var addr = SYSCALLS.get(),\n            len = SYSCALLS.get();\n        var info = SYSCALLS.mappings[addr];\n        if (!info) return 0;\n        if (len === info.len) {\n            var stream = FS.getStream(info.fd);\n            SYSCALLS.doMsync(addr, stream, len, info.flags);\n            FS.munmap(stream);\n            SYSCALLS.mappings[addr] = null;\n            if (info.allocated) {\n                _free(info.malloc)\n            }\n        }\n        return 0\n    } catch (e) {\n        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno\n    }\n}\n\nfunction ___unlock() { }\n\nfunction _abort() {\n    Module["abort"]()\n}\nvar ENV = {};\n\nfunction _getenv(name) {\n    if (name === 0) return 0;\n    name = Pointer_stringify(name);\n    if (!ENV.hasOwnProperty(name)) return 0;\n    if (_getenv.ret) _free(_getenv.ret);\n    _getenv.ret = allocateUTF8(ENV[name]);\n    return _getenv.ret\n}\n\nfunction _llvm_stackrestore(p) {\n    var self = _llvm_stacksave;\n    var ret = self.LLVM_SAVEDSTACKS[p];\n    self.LLVM_SAVEDSTACKS.splice(p, 1);\n    stackRestore(ret)\n}\n\nfunction _llvm_stacksave() {\n    var self = _llvm_stacksave;\n    if (!self.LLVM_SAVEDSTACKS) {\n        self.LLVM_SAVEDSTACKS = []\n    }\n    self.LLVM_SAVEDSTACKS.push(stackSave());\n    return self.LLVM_SAVEDSTACKS.length - 1\n}\n\nfunction _llvm_trap() {\n    abort("trap!")\n}\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    return dest\n}\n\nfunction _pthread_cond_destroy() {\n    return 0\n}\n\nfunction _pthread_cond_init() {\n    return 0\n}\n\nfunction _pthread_cond_signal() {\n    return 0\n}\n\nfunction _pthread_cond_wait() {\n    return 0\n}\n\nfunction _pthread_create() {\n    return 11\n}\nvar PTHREAD_SPECIFIC = {};\n\nfunction _pthread_getspecific(key) {\n    return PTHREAD_SPECIFIC[key] || 0\n}\n\nfunction _pthread_join() { }\nvar PTHREAD_SPECIFIC_NEXT_KEY = 1;\n\nfunction _pthread_key_create(key, destructor) {\n    if (key == 0) {\n        return ERRNO_CODES.EINVAL\n    }\n    HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY;\n    PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\n    PTHREAD_SPECIFIC_NEXT_KEY++;\n    return 0\n}\n\nfunction _pthread_mutex_destroy() { }\n\nfunction _pthread_mutex_init() { }\n\nfunction _pthread_once(ptr, func) {\n    if (!_pthread_once.seen) _pthread_once.seen = {};\n    if (ptr in _pthread_once.seen) return;\n    Module["dynCall_v"](func);\n    _pthread_once.seen[ptr] = 1\n}\n\nfunction _pthread_setspecific(key, value) {\n    if (!(key in PTHREAD_SPECIFIC)) {\n        return ERRNO_CODES.EINVAL\n    }\n    PTHREAD_SPECIFIC[key] = value;\n    return 0\n}\n\nfunction __isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nfunction __arraySum(array, index) {\n    var sum = 0;\n    for (var i = 0; i <= index; sum += array[i++]);\n    return sum\n}\nvar __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\nfunction __addDays(date, days) {\n    var newDate = new Date(date.getTime());\n    while (days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n            days -= daysInCurrentMonth - newDate.getDate() + 1;\n            newDate.setDate(1);\n            if (currentMonth < 11) {\n                newDate.setMonth(currentMonth + 1)\n            } else {\n                newDate.setMonth(0);\n                newDate.setFullYear(newDate.getFullYear() + 1)\n            }\n        } else {\n            newDate.setDate(newDate.getDate() + days);\n            return newDate\n        }\n    }\n    return newDate\n}\n\nfunction _strftime(s, maxsize, format, tm) {\n    var tm_zone = HEAP32[tm + 40 >> 2];\n    var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[tm + 4 >> 2],\n        tm_hour: HEAP32[tm + 8 >> 2],\n        tm_mday: HEAP32[tm + 12 >> 2],\n        tm_mon: HEAP32[tm + 16 >> 2],\n        tm_year: HEAP32[tm + 20 >> 2],\n        tm_wday: HEAP32[tm + 24 >> 2],\n        tm_yday: HEAP32[tm + 28 >> 2],\n        tm_isdst: HEAP32[tm + 32 >> 2],\n        tm_gmtoff: HEAP32[tm + 36 >> 2],\n        tm_zone: tm_zone ? Pointer_stringify(tm_zone) : ""\n    };\n    var pattern = Pointer_stringify(format);\n    var EXPANSION_RULES_1 = {\n        "%c": "%a %b %d %H:%M:%S %Y",\n        "%D": "%m/%d/%y",\n        "%F": "%Y-%m-%d",\n        "%h": "%b",\n        "%r": "%I:%M:%S %p",\n        "%R": "%H:%M",\n        "%T": "%H:%M:%S",\n        "%x": "%m/%d/%y",\n        "%X": "%H:%M:%S"\n    };\n    for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule])\n    }\n    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];\n    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];\n\n    function leadingSomething(value, digits, character) {\n        var str = typeof value === "number" ? value.toString() : value || "";\n        while (str.length < digits) {\n            str = character[0] + str\n        }\n        return str\n    }\n\n    function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, "0")\n    }\n\n    function compareByDay(date1, date2) {\n        function sgn(value) {\n            return value < 0 ? -1 : value > 0 ? 1 : 0\n        }\n        var compare;\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n                compare = sgn(date1.getDate() - date2.getDate())\n            }\n        }\n        return compare\n    }\n\n    function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n            case 0:\n                return new Date(janFourth.getFullYear() - 1, 11, 29);\n            case 1:\n                return janFourth;\n            case 2:\n                return new Date(janFourth.getFullYear(), 0, 3);\n            case 3:\n                return new Date(janFourth.getFullYear(), 0, 2);\n            case 4:\n                return new Date(janFourth.getFullYear(), 0, 1);\n            case 5:\n                return new Date(janFourth.getFullYear() - 1, 11, 31);\n            case 6:\n                return new Date(janFourth.getFullYear() - 1, 11, 30)\n        }\n    }\n\n    function getWeekBasedYear(date) {\n        var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n                return thisDate.getFullYear() + 1\n            } else {\n                return thisDate.getFullYear()\n            }\n        } else {\n            return thisDate.getFullYear() - 1\n        }\n    }\n    var EXPANSION_RULES_2 = {\n        "%a": (function (date) {\n            return WEEKDAYS[date.tm_wday].substring(0, 3)\n        }),\n        "%A": (function (date) {\n            return WEEKDAYS[date.tm_wday]\n        }),\n        "%b": (function (date) {\n            return MONTHS[date.tm_mon].substring(0, 3)\n        }),\n        "%B": (function (date) {\n            return MONTHS[date.tm_mon]\n        }),\n        "%C": (function (date) {\n            var year = date.tm_year + 1900;\n            return leadingNulls(year / 100 | 0, 2)\n        }),\n        "%d": (function (date) {\n            return leadingNulls(date.tm_mday, 2)\n        }),\n        "%e": (function (date) {\n            return leadingSomething(date.tm_mday, 2, " ")\n        }),\n        "%g": (function (date) {\n            return getWeekBasedYear(date).toString().substring(2)\n        }),\n        "%G": (function (date) {\n            return getWeekBasedYear(date)\n        }),\n        "%H": (function (date) {\n            return leadingNulls(date.tm_hour, 2)\n        }),\n        "%I": (function (date) {\n            var twelveHour = date.tm_hour;\n            if (twelveHour == 0) twelveHour = 12;\n            else if (twelveHour > 12) twelveHour -= 12;\n            return leadingNulls(twelveHour, 2)\n        }),\n        "%j": (function (date) {\n            return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3)\n        }),\n        "%m": (function (date) {\n            return leadingNulls(date.tm_mon + 1, 2)\n        }),\n        "%M": (function (date) {\n            return leadingNulls(date.tm_min, 2)\n        }),\n        "%n": (function () {\n            return "\\n"\n        }),\n        "%p": (function (date) {\n            if (date.tm_hour >= 0 && date.tm_hour < 12) {\n                return "AM"\n            } else {\n                return "PM"\n            }\n        }),\n        "%S": (function (date) {\n            return leadingNulls(date.tm_sec, 2)\n        }),\n        "%t": (function () {\n            return "\\t"\n        }),\n        "%u": (function (date) {\n            var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);\n            return day.getDay() || 7\n        }),\n        "%U": (function (date) {\n            var janFirst = new Date(date.tm_year + 1900, 0, 1);\n            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n            var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n            if (compareByDay(firstSunday, endDate) < 0) {\n                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n                return leadingNulls(Math.ceil(days / 7), 2)\n            }\n            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00"\n        }),\n        "%V": (function (date) {\n            var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\n            var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\n            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n            var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n                return "53"\n            }\n            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n                return "01"\n            }\n            var daysDifference;\n            if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\n                daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate()\n            } else {\n                daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate()\n            }\n            return leadingNulls(Math.ceil(daysDifference / 7), 2)\n        }),\n        "%w": (function (date) {\n            var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);\n            return day.getDay()\n        }),\n        "%W": (function (date) {\n            var janFirst = new Date(date.tm_year, 0, 1);\n            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n            var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n            if (compareByDay(firstMonday, endDate) < 0) {\n                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n                return leadingNulls(Math.ceil(days / 7), 2)\n            }\n            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00"\n        }),\n        "%y": (function (date) {\n            return (date.tm_year + 1900).toString().substring(2)\n        }),\n        "%Y": (function (date) {\n            return date.tm_year + 1900\n        }),\n        "%z": (function (date) {\n            var off = date.tm_gmtoff;\n            var ahead = off >= 0;\n            off = Math.abs(off) / 60;\n            off = off / 60 * 100 + off % 60;\n            return (ahead ? "+" : "-") + String("0000" + off).slice(-4)\n        }),\n        "%Z": (function (date) {\n            return date.tm_zone\n        }),\n        "%%": (function () {\n            return "%"\n        })\n    };\n    for (var rule in EXPANSION_RULES_2) {\n        if (pattern.indexOf(rule) >= 0) {\n            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date))\n        }\n    }\n    var bytes = intArrayFromString(pattern, false);\n    if (bytes.length > maxsize) {\n        return 0\n    }\n    writeArrayToMemory(bytes, s);\n    return bytes.length - 1\n}\n\nfunction _strftime_l(s, maxsize, format, tm) {\n    return _strftime(s, maxsize, format, tm)\n}\nFS.staticInit();\n__ATINIT__.unshift((function () {\n    if (!Module["noFSInit"] && !FS.init.initialized) FS.init()\n}));\n__ATMAIN__.push((function () {\n    FS.ignorePermissions = false\n}));\n__ATEXIT__.push((function () {\n    FS.quit()\n}));\n__ATINIT__.unshift((function () {\n    TTY.init()\n}));\n__ATEXIT__.push((function () {\n    TTY.shutdown()\n}));\nif (ENVIRONMENT_IS_NODE) {\n    var fs = require("fs");\n    var NODEJS_PATH = require("path");\n    NODEFS.staticInit()\n}\nDYNAMICTOP_PTR = staticAlloc(4);\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\nDYNAMIC_BASE = alignMemory(STACK_MAX);\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\nstaticSealed = true;\n\nfunction intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array\n}\nModule["wasmTableSize"] = 644;\nModule["wasmMaxTableSize"] = 644;\nModule.asmGlobalArg = {};\nModule.asmLibraryArg = {\n    "abort": abort,\n    "enlargeMemory": enlargeMemory,\n    "getTotalMemory": getTotalMemory,\n    "abortOnCannotGrowMemory": abortOnCannotGrowMemory,\n    "___assert_fail": ___assert_fail,\n    "___cxa_allocate_exception": ___cxa_allocate_exception,\n    "___cxa_pure_virtual": ___cxa_pure_virtual,\n    "___cxa_throw": ___cxa_throw,\n    "___lock": ___lock,\n    "___map_file": ___map_file,\n    "___setErrNo": ___setErrNo,\n    "___syscall140": ___syscall140,\n    "___syscall145": ___syscall145,\n    "___syscall146": ___syscall146,\n    "___syscall54": ___syscall54,\n    "___syscall6": ___syscall6,\n    "___syscall91": ___syscall91,\n    "___unlock": ___unlock,\n    "_abort": _abort,\n    "_emscripten_memcpy_big": _emscripten_memcpy_big,\n    "_getenv": _getenv,\n    "_llvm_stackrestore": _llvm_stackrestore,\n    "_llvm_stacksave": _llvm_stacksave,\n    "_llvm_trap": _llvm_trap,\n    "_pthread_cond_destroy": _pthread_cond_destroy,\n    "_pthread_cond_init": _pthread_cond_init,\n    "_pthread_cond_signal": _pthread_cond_signal,\n    "_pthread_cond_wait": _pthread_cond_wait,\n    "_pthread_create": _pthread_create,\n    "_pthread_getspecific": _pthread_getspecific,\n    "_pthread_join": _pthread_join,\n    "_pthread_key_create": _pthread_key_create,\n    "_pthread_mutex_destroy": _pthread_mutex_destroy,\n    "_pthread_mutex_init": _pthread_mutex_init,\n    "_pthread_once": _pthread_once,\n    "_pthread_setspecific": _pthread_setspecific,\n    "_strftime_l": _strftime_l,\n    "DYNAMICTOP_PTR": DYNAMICTOP_PTR,\n    "STACKTOP": STACKTOP\n};\nvar asm = Module["asm"](Module.asmGlobalArg, Module.asmLibraryArg, buffer);\nModule["asm"] = asm;\nvar __GLOBAL__I_000101 = Module["__GLOBAL__I_000101"] = (function () {\n    return Module["asm"]["__GLOBAL__I_000101"].apply(null, arguments)\n});\nvar __GLOBAL__sub_I_encoder_types_cc = Module["__GLOBAL__sub_I_encoder_types_cc"] = (function () {\n    return Module["asm"]["__GLOBAL__sub_I_encoder_types_cc"].apply(null, arguments)\n});\nvar __GLOBAL__sub_I_iostream_cpp = Module["__GLOBAL__sub_I_iostream_cpp"] = (function () {\n    return Module["asm"]["__GLOBAL__sub_I_iostream_cpp"].apply(null, arguments)\n});\nvar ___errno_location = Module["___errno_location"] = (function () {\n    return Module["asm"]["___errno_location"].apply(null, arguments)\n});\nvar _de265_change_framerate = Module["_de265_change_framerate"] = (function () {\n    return Module["asm"]["_de265_change_framerate"].apply(null, arguments)\n});\nvar _de265_decode = Module["_de265_decode"] = (function () {\n    return Module["asm"]["_de265_decode"].apply(null, arguments)\n});\nvar _de265_flush_data = Module["_de265_flush_data"] = (function () {\n    return Module["asm"]["_de265_flush_data"].apply(null, arguments)\n});\nvar _de265_free_decoder = Module["_de265_free_decoder"] = (function () {\n    return Module["asm"]["_de265_free_decoder"].apply(null, arguments)\n});\nvar _de265_get_bits_per_pixel = Module["_de265_get_bits_per_pixel"] = (function () {\n    return Module["asm"]["_de265_get_bits_per_pixel"].apply(null, arguments)\n});\nvar _de265_get_chroma_format = Module["_de265_get_chroma_format"] = (function () {\n    return Module["asm"]["_de265_get_chroma_format"].apply(null, arguments)\n});\nvar _de265_get_error_text = Module["_de265_get_error_text"] = (function () {\n    return Module["asm"]["_de265_get_error_text"].apply(null, arguments)\n});\nvar _de265_get_image_height = Module["_de265_get_image_height"] = (function () {\n    return Module["asm"]["_de265_get_image_height"].apply(null, arguments)\n});\nvar _de265_get_image_plane = Module["_de265_get_image_plane"] = (function () {\n    return Module["asm"]["_de265_get_image_plane"].apply(null, arguments)\n});\nvar _de265_get_image_width = Module["_de265_get_image_width"] = (function () {\n    return Module["asm"]["_de265_get_image_width"].apply(null, arguments)\n});\nvar _de265_get_next_picture = Module["_de265_get_next_picture"] = (function () {\n    return Module["asm"]["_de265_get_next_picture"].apply(null, arguments)\n});\nvar _de265_isOK = Module["_de265_isOK"] = (function () {\n    return Module["asm"]["_de265_isOK"].apply(null, arguments)\n});\nvar _de265_new_decoder = Module["_de265_new_decoder"] = (function () {\n    return Module["asm"]["_de265_new_decoder"].apply(null, arguments)\n});\nvar _de265_push_data = Module["_de265_push_data"] = (function () {\n    return Module["asm"]["_de265_push_data"].apply(null, arguments)\n});\nvar _de265_reset = Module["_de265_reset"] = (function () {\n    return Module["asm"]["_de265_reset"].apply(null, arguments)\n});\nvar _de265_set_framerate_ratio = Module["_de265_set_framerate_ratio"] = (function () {\n    return Module["asm"]["_de265_set_framerate_ratio"].apply(null, arguments)\n});\nvar _de265_set_parameter_bool = Module["_de265_set_parameter_bool"] = (function () {\n    return Module["asm"]["_de265_set_parameter_bool"].apply(null, arguments)\n});\nvar _emscripten_replace_memory = Module["_emscripten_replace_memory"] = (function () {\n    return Module["asm"]["_emscripten_replace_memory"].apply(null, arguments)\n});\nvar _free = Module["_free"] = (function () {\n    return Module["asm"]["_free"].apply(null, arguments)\n});\nvar _malloc = Module["_malloc"] = (function () {\n    return Module["asm"]["_malloc"].apply(null, arguments)\n});\nvar stackAlloc = Module["stackAlloc"] = (function () {\n    return Module["asm"]["stackAlloc"].apply(null, arguments)\n});\nvar stackRestore = Module["stackRestore"] = (function () {\n    return Module["asm"]["stackRestore"].apply(null, arguments)\n});\nvar stackSave = Module["stackSave"] = (function () {\n    return Module["asm"]["stackSave"].apply(null, arguments)\n});\nvar dynCall_v = Module["dynCall_v"] = (function () {\n    return Module["asm"]["dynCall_v"].apply(null, arguments)\n});\nvar dynCall_vi = Module["dynCall_vi"] = (function () {\n    return Module["asm"]["dynCall_vi"].apply(null, arguments)\n});\nModule["asm"] = asm;\nModule["ccall"] = ccall;\nModule["cwrap"] = cwrap;\n\nfunction ExitStatus(status) {\n    this.name = "ExitStatus";\n    this.message = "Program terminated with exit(" + status + ")";\n    this.status = status\n}\nExitStatus.prototype = new Error;\nExitStatus.prototype.constructor = ExitStatus;\ndependenciesFulfilled = function runCaller() {\n    if (!Module["calledRun"]) run();\n    if (!Module["calledRun"]) dependenciesFulfilled = runCaller\n};\n\nfunction run(args) {\n    args = args || Module["arguments"];\n    if (runDependencies > 0) {\n        return\n    }\n    preRun();\n    if (runDependencies > 0) return;\n    if (Module["calledRun"]) return;\n\n    function doRun() {\n        if (Module["calledRun"]) return;\n        Module["calledRun"] = true;\n        if (ABORT) return;\n        ensureInitRuntime();\n        preMain();\n        if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();\n        postRun()\n    }\n    if (Module["setStatus"]) {\n        Module["setStatus"]("Running...");\n        setTimeout((function () {\n            setTimeout((function () {\n                Module["setStatus"]("")\n            }), 1);\n            doRun()\n        }), 1)\n    } else {\n        doRun()\n    }\n}\nModule["run"] = run;\n\nfunction abort(what) {\n    if (Module["onAbort"]) {\n        Module["onAbort"](what)\n    }\n    if (what !== undefined) {\n        out(what);\n        err(what);\n        what = JSON.stringify(what)\n    } else {\n        what = ""\n    }\n    ABORT = true;\n    EXITSTATUS = 1;\n    throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info."\n}\nModule["abort"] = abort;\nif (Module["preInit"]) {\n    if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];\n    while (Module["preInit"].length > 0) {\n        Module["preInit"].pop()()\n    }\n}\nModule["noExitRuntime"] = true;\nrun();\nvar libde265 = {\n    de265_get_error_text: cwrap("de265_get_error_text", "string", ["number"]),\n    de265_isOK: cwrap("de265_isOK", "number", ["number"]),\n    de265_chroma_mono: 0,\n    de265_chroma_420: 1,\n    de265_chroma_422: 2,\n    de265_chroma_444: 3,\n    de265_get_image_width: cwrap("de265_get_image_width", "number", ["number", "number"]),\n    de265_get_image_height: cwrap("de265_get_image_height", "number", ["number", "number"]),\n    de265_get_chroma_format: cwrap("de265_get_chroma_format", "number", ["number"]),\n    de265_get_bits_per_pixel: cwrap("de265_get_bits_per_pixel", "number", ["number", "number"]),\n    de265_get_image_plane: cwrap("de265_get_image_plane", "number", ["number", "number", "number"]),\n    de265_new_decoder: cwrap("de265_new_decoder", "number"),\n    de265_free_decoder: cwrap("de265_free_decoder", "number", ["number"]),\n    de265_push_data: cwrap("de265_push_data", "number", ["number", "array", "number", "number", "number"]),\n    de265_flush_data: cwrap("de265_flush_data", "number", ["number"]),\n    de265_decode: cwrap("de265_decode", "number", ["number", "number"]),\n    de265_reset: cwrap("de265_reset", "number", ["number"]),\n    de265_get_next_picture: cwrap("de265_get_next_picture", "number", ["number"]),\n    de265_set_framerate_ratio: cwrap("de265_set_framerate_ratio", "number", ["number", "number"]),\n    DE265_DECODER_PARAM_DISABLE_DEBLOCKING: 7,\n    DE265_DECODER_PARAM_DISABLE_SAO: 8,\n    de265_set_parameter_bool: cwrap("de265_set_parameter_bool", "number", ["number", "number", "number"])\n};\nvar Image = (function (decoder, img) {\n    this.decoder = decoder;\n    this.img = img;\n    this.width = null;\n    this.height = null\n});\nImage.prototype.free = (function () { });\nImage.prototype.get_width = (function () {\n    if (this.width === null) {\n        this.width = libde265.de265_get_image_width(this.img, 0)\n    }\n    return this.width\n});\nImage.prototype.get_height = (function () {\n    if (this.height === null) {\n        this.height = libde265.de265_get_image_height(this.img, 0)\n    }\n    return this.height\n});\nImage.prototype.display = (function (imageData, callback) {\n    var w = this.get_width();\n    var h = this.get_height();\n    var chroma = libde265.de265_get_chroma_format(this.img);\n    var stride = _malloc(4);\n    var y = libde265.de265_get_image_plane(this.img, 0, stride);\n    var stridey = getValue(stride, "i32");\n    var bppy = libde265.de265_get_bits_per_pixel(this.img, 0);\n    var u = libde265.de265_get_image_plane(this.img, 1, stride);\n    var strideu = getValue(stride, "i32");\n    var bppu = libde265.de265_get_bits_per_pixel(this.img, 1);\n    var v = libde265.de265_get_image_plane(this.img, 2, stride);\n    var stridev = getValue(stride, "i32");\n    var bppv = libde265.de265_get_bits_per_pixel(this.img, 2);\n    _free(stride); \n    this.decoder.convert_yuvData(y, u, v, w, h, stridey, strideu, stridev);//[yuv]\n});\nvar Decoder = (function () {\n    this.image_callback = null;\n    this.more = _malloc(2);\n    this.stop = false;\n    this.ctx = libde265.de265_new_decoder();\n    this.toBeDecodeQueue = [];\n    this.start()\n});\nDecoder.prototype.free = (function () {\n    libde265.de265_free_decoder(this.ctx);\n    this.ctx = null;\n    _free(this.more);\n    this.more = null;\n    this.toBeDecodeQueue = null\n});\nDecoder.prototype.start = (function () {\n    this.started = true;\n});\nDecoder.prototype.resume = (function () {\n    this.isPausing = false;\n});\nDecoder.prototype.consumeData = (function (vdata) {\n    var that = this;\n    if (this.started && !this.isPausing) {\n        var err = decoder.push_data(vdata);\n        if (!libde265.de265_isOK(err)) {\n            console.log(libde265.de265_get_error_text(err));\n            return\n        }\n        decoder.decode();\n    }\n});\nDecoder.prototype.set_image_callback = (function (callback) {\n    this.image_callback = callback\n});\nDecoder.prototype.reset = (function () {\n    libde265.de265_reset(this.ctx)\n});\nDecoder.prototype.push_data = (function (data, pts) {\n    pts = pts || 0;\n    return libde265.de265_push_data(this.ctx, data, data.length, pts, 0)\n});\nDecoder.prototype.flush = (function () {\n    this.stop = true;\n    return libde265.de265_flush_data(this.ctx);\n});\nDecoder.prototype.has_more = (function () {\n    return !this.stop || getValue(this.more, "i16") !== 0\n});\nDecoder.prototype.set_framerate_ratio = (function (ratio) {\n    libde265.de265_set_framerate_ratio(this.ctx, ratio)\n});\nDecoder.prototype.disable_filters = (function (disable) {\n    libde265.de265_set_parameter_bool(this.ctx, libde265.DE265_DECODER_PARAM_DISABLE_DEBLOCKING, !!disable);\n    libde265.de265_set_parameter_bool(this.ctx, libde265.DE265_DECODER_PARAM_DISABLE_SAO, !!disable)\n});\nDecoder.prototype.decode = (function (callback) {\n    var err;\n    setValue(this.more, 1, "i16");\n    this.lastDecBt = new Date().getTime();\n    while (getValue(this.more, "i16") !== 0) {\n        err = libde265.de265_decode(this.ctx, this.more);\n        if (!libde265.de265_isOK(err)) {\n            err = 0;\n            setValue(this.more, 0, "i16");\n            break\n        }\n        var img = libde265.de265_get_next_picture(this.ctx);\n        if (img) {\n            if (this.image_callback) this.image_callback(new Image(this, img))\n        }\n    }\n    callback && callback(err);\n    return\n});\nDecoder.prototype.convert_yuv2rgb = (function (chroma, y, u, v, w, h, stridey, strideu, stridev, bppy, bppu, bppv) {\n    y = new Uint8Array(HEAPU8.subarray(y, y + h * stridey));\n    u = new Uint8Array(HEAPU8.subarray(u, u + h * strideu));\n    v = new Uint8Array(HEAPU8.subarray(v, v + h * stridev));\n    var d = {\n        "chroma": chroma,\n        "y": y,\n        "u": u,\n        "v": v,\n        "w": w,\n        "h": h,\n        "stridey": stridey,\n        "strideu": strideu,\n        "stridev": stridev,\n        "bppy": bppy,\n        "bppu": bppu,\n        "bppv": bppv,\n        "decCost": new Date().getTime() - this.lastDecBt,\n    };\n    postMessage(d, [y.buffer, u.buffer, v.buffer]);\n});\n\nDecoder.prototype.convert_yuvData = (function (y, u, v, w, h, stridey, strideu, stridev) {\n    var yData = HEAPU8.subarray(y, y + (h * stridey));\n    var uData = HEAPU8.subarray(u, u + (h * strideu));\n    var vData = HEAPU8.subarray(v, v + (h * stridev));\n\n    var yuvData = new Uint8Array(h * w + h / 2 * w / 2 * 2);\n    for (var i = 0; i < h; i++) {\n        yuvData.set(yData.subarray(i * stridey, i * stridey + w), w * i);\n    }\n    for (var i = 0; i < h / 2; i++) {\n        var offset = w * h + w / 2 * i;\n        yuvData.set(uData.subarray(i * strideu, i * strideu + w / 2), offset);\n    }\n    for (var i = 0; i < h / 2; i++) {\n        var offset = w * h * 1.25 + w / 2 * i;\n        yuvData.set(vData.subarray(i * stridev, i * stridev + w / 2), offset);\n    }\n    yData = null;\n    uData = null;\n    vData = null;\n\n    var d = {\n        "w": w,\n        "h": h,\n        'yuvData': yuvData,\n        'id': this.canvasId,\n};\n    postMessage(d, [yuvData.buffer]);\n});\n\nModule["print"] = (function (text) {\n    text = Array.prototype.slice.call(arguments).join(" ");\n    console.log(text)\n});\nModule["printErr"] = (function (text) {\n    text = Array.prototype.slice.call(arguments).join(" ");\n    console.error(text)\n});\nvar decoder;\nModule["postRun"] = (function () {\n    decoder = new Decoder;\n    decoder.set_image_callback((function (image) {\n        image.display();\n        image.free()\n    }))\n});\n        onmessage = (function (e) {\n    switch (e.data.cmd) {\n        case 'SN':\n        case 'IP':\n       if(!decoder) return;\n       decoder.canvasId = e.data.id;\n            decoder.consumeData(e.data.data);\n            break;\n        case 'exit':\n            self.close();\n            break;\n    };\n})`;BLOBURL=sessionStorage.getItem("isDebug")?window.location.origin+"/dist/common/":getResourcesPath();var libde265WorkerBlob=libde265WorkerBlob.replace("BLOBURL/",BLOBURL+"video/"),isWebgl2=document.createElement("canvas").getContext("webgl2"),renderUrl=["audio/g7712pcm.js","audio/pcm-player.js","audio/aurora.js","audio/aac.js","video/libde265-wasm.js"];function addJavascript(n){for(var e=document.createElement("script"),t=0;t<n.length;t++)(e=document.createElement("script")).type="text/javascript",e.src=BLOBURL+n[t],$("body").prepend(e)}function getResourcesPath(){var n=document.currentScript.src.split("wfs")[0],e=n.split("/");return n.replace("/"+e[e.length-2],"")}renderUrl.push(isWebgl2?"video/super-render20.js":"video/super-render10.js"),addJavascript(renderUrl);var client=[],h265Conver=[],configInfo=[],littleEndian=function(){var n=new ArrayBuffer(2);return new DataView(n).setInt16(0,256,!0),256===new Int16Array(n)[0]}(),ErrorDetails={MANIFEST_LOAD_ERROR:"manifestLoadError",MANIFEST_LOAD_TIMEOUT:"manifestLoadTimeOut",MANIFEST_PARSING_ERROR:"manifestParsingError",MANIFEST_INCOMPATIBLE_CODECS_ERROR:"manifestIncompatibleCodecsError",LEVEL_LOAD_ERROR:"levelLoadError",LEVEL_LOAD_TIMEOUT:"levelLoadTimeOut",LEVEL_SWITCH_ERROR:"levelSwitchError",AUDIO_TRACK_LOAD_ERROR:"audioTrackLoadError",AUDIO_TRACK_LOAD_TIMEOUT:"audioTrackLoadTimeOut",FRAG_LOAD_ERROR:"fragLoadError",FRAG_LOOP_LOADING_ERROR:"fragLoopLoadingError",FRAG_LOAD_TIMEOUT:"fragLoadTimeOut",FRAG_DECRYPT_ERROR:"fragDecryptError",FRAG_PARSING_ERROR:"fragParsingError",KEY_LOAD_ERROR:"keyLoadError",KEY_LOAD_TIMEOUT:"keyLoadTimeOut",BUFFER_ADD_CODEC_ERROR:"bufferAddCodecError",BUFFER_APPEND_ERROR:"bufferAppendError",BUFFER_APPENDING_ERROR:"bufferAppendingError",BUFFER_STALLED_ERROR:"bufferStalledError",BUFFER_FULL_ERROR:"bufferFullError",BUFFER_SEEK_OVER_HOLE:"bufferSeekOverHole",INTERNAL_EXCEPTION:"internalException"};function isJsonString(n){if("{"===n[0]&&"}"===n[n.length-1])try{if("object"==typeof JSON.parse(n))return!0}catch(n){}return!1}!function(n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).Wfs=n()}(function(){return function r(a,o,i){function s(e,n){if(!o[e]){if(!a[e]){var t="function"==typeof require&&require;if(!n&&t)return t(e,!0);if(u)return u(e,!0);throw(t=new Error("Cannot find module '"+e+"'")).code="MODULE_NOT_FOUND",t}t=o[e]={exports:{}},a[e][0].call(t.exports,function(n){return s(a[e][1][n]||n)},t,t.exports,r,a,o,i)}return o[e].exports}for(var u="function"==typeof require&&require,n=0;n<i.length;n++)s(i[n]);return s}({1:[function(n,e,t){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function u(n){return"function"==typeof n}function d(n){return"object"==typeof n&&null!==n}function l(n){return void 0===n}((e.exports=r).EventEmitter=r).prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(n){if("number"!=typeof n||n<0||isNaN(n))throw TypeError("n must be a positive number");return this._maxListeners=n,this},r.prototype.emit=function(n){var e,t,r,a,o,i;if(this._events||(this._events={}),"error"===n&&(!this._events.error||d(this._events.error)&&!this._events.error.length)){if((e=arguments[1])instanceof Error)throw e;var s=new Error('Uncaught, unspecified "error" event. ('+e+")");throw s.context=e,s}if(l(t=this._events[n]))return!1;if(u(t))switch(arguments.length){case 1:t.call(this);break;case 2:t.call(this,arguments[1]);break;case 3:t.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),t.apply(this,a)}else if(d(t))for(a=Array.prototype.slice.call(arguments,1),r=(i=t.slice()).length,o=0;o<r;o++)i[o].apply(this,a);return!0},r.prototype.on=r.prototype.addListener=function(n,e){var t;if(!u(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",n,u(e.listener)?e.listener:e),this._events[n]?d(this._events[n])?this._events[n].push(e):this._events[n]=[this._events[n],e]:this._events[n]=e,d(this._events[n])&&!this._events[n].warned&&(t=l(this._maxListeners)?r.defaultMaxListeners:this._maxListeners)&&0<t&&this._events[n].length>t&&(this._events[n].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[n].length),"function"==typeof console.trace&&console.trace()),this},r.prototype.once=function(n,e){if(!u(e))throw TypeError("listener must be a function");var t=!1;function r(){this.removeListener(n,r),t||(t=!0,e.apply(this,arguments))}return r.listener=e,this.on(n,r),this},r.prototype.removeListener=function(n,e){var t,r,a,o;if(!u(e))throw TypeError("listener must be a function");if(!this._events||!this._events[n])return this;if(a=(t=this._events[n]).length,r=-1,t===e||u(t.listener)&&t.listener===e)delete this._events[n],this._events.removeListener&&this.emit("removeListener",n,e);else if(d(t)){for(o=a;0<o--;)if(t[o]===e||t[o].listener&&t[o].listener===e){r=o;break}if(r<0)return this;1===t.length?(t.length=0,delete this._events[n]):t.splice(r,1),this._events.removeListener&&this.emit("removeListener",n,e)}return this},r.prototype.removeAllListeners=function(n){var e,t;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[n]&&delete this._events[n],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(u(t=this._events[n]))this.removeListener(n,t);else if(t)for(;t.length;)this.removeListener(n,t[t.length-1]);return delete this._events[n],this},r.prototype.listeners=function(n){n=this._events&&this._events[n]?u(this._events[n])?[this._events[n]]:this._events[n].slice():[];return n},r.prototype.listenerCount=function(n){if(this._events){n=this._events[n];if(u(n))return 1;if(n)return n.length}return 0},r.listenerCount=function(n,e){return n.listenerCount(e)}},{}],2:[function(n,e,t){var r,a,e=e.exports={};function o(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function s(e){if(r===setTimeout)return setTimeout(e,0);if((r===o||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(n){try{return r.call(null,e,0)}catch(n){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:o}catch(n){r=o}try{a="function"==typeof clearTimeout?clearTimeout:i}catch(n){a=i}}();var u,d=[],l=!1,f=-1;function c(){l&&u&&(l=!1,u.length?d=u.concat(d):f=-1,d.length&&p())}function p(){if(!l){var n=s(c);l=!0;for(var e=d.length;e;){for(u=d,d=[];++f<e;)u&&u[f].run();f=-1,e=d.length}u=null,l=!1,function(e){if(a===clearTimeout)return clearTimeout(e);if((a===i||!a)&&clearTimeout)return a=clearTimeout,clearTimeout(e);try{a(e)}catch(n){try{return a.call(null,e)}catch(n){return a.call(this,e)}}}(n)}}function h(n,e){this.fun=n,this.array=e}function m(){}e.nextTick=function(n){var e=new Array(arguments.length-1);if(1<arguments.length)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];d.push(new h(n,e)),1!==d.length||l||s(p)},h.prototype.run=function(){this.fun.apply(null,this.array)},e.title="browser",e.browser=!0,e.env={},e.argv=[],e.version="",e.versions={},e.on=m,e.addListener=m,e.once=m,e.off=m,e.removeListener=m,e.removeAllListeners=m,e.emit=m,e.prependListener=m,e.prependOnceListener=m,e.listeners=function(n){return[]},e.binding=function(n){throw new Error("process.binding is not supported")},e.cwd=function(){return"/"},e.chdir=function(n){throw new Error("process.chdir is not supported")},e.umask=function(){return 0}},{}],3:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var o=s(n("../events")),i=s(n("../event-handler"));function s(n){return n&&n.__esModule?n:{default:n}}(function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)})(u,i.default),r(u,[{key:"destroy",value:function(){i.default.prototype.destroy.call(this)}},{key:"onMediaAttaching",value:function(n){var e=this.media=n.media;this.mediaType=n.mediaType,this.websocketUrl=n.websocketUrl,this.connectId=n.id,e&&("H264Raw"===this.mediaType?(n=this.mediaSource=new MediaSource,this.onmso=this.onMediaSourceOpen.bind(this),this.onmse=this.onMediaSourceEnded.bind(this),this.onmsc=this.onMediaSourceClose.bind(this),n.addEventListener("sourceopen",this.onmso),n.addEventListener("sourceended",this.onmse),n.addEventListener("sourceclose",this.onmsc),e.src=URL.createObjectURL(n)):"H265Raw"===this.mediaType&&this.onMediaSourceOpen())}},{key:"onMediaDetaching",value:function(){}},{key:"onBufferAppending",value:function(n){this.segments?this.segments.push(n):this.segments=[n],this.doAppending()}},{key:"onMediaSourceClose",value:function(){console.log("media source closed")}},{key:"onMediaSourceEnded",value:function(){console.log("media source ended")}},{key:"onSBUpdateEnd",value:function(n){var e;-1<navigator.vendor.indexOf("Apple")&&this.mediaSource.duration!==Number.POSITIVE_INFINITY&&0===this.media.currentTime&&0<this.mediaSource.duration&&(0<(e=this.sourceBuffer.video.buffered).length&&(this.media.currentTime=e.end(0),this.mediaSource.duration=Number.POSITIVE_INFINITY)),this.preData==this.media.currentTime&&this.media.currentTime,this.preData=this.media.currentTime,this.appending=!1,this.doAppending(),this.updateMediaElementDuration()}},{key:"updateMediaElementDuration",value:function(){}},{key:"onMediaSourceOpen",value:function(){var n=this.mediaSource;n&&n.removeEventListener("sourceopen",this.onmso),"FMp4"===this.mediaType&&this.checkPendingTracks(),this.wfs.trigger(o.default.MEDIA_ATTACHED,{media:this.media,mediaType:this.mediaType,websocketUrl:this.websocketUrl,connectId:this.connectId})}},{key:"checkPendingTracks",value:function(){this.createSourceBuffers({tracks:"video",mimeType:""}),this.pendingTracks={}}},{key:"onBufferReset",value:function(n){"H264Raw"===this.mediaType&&this.createSourceBuffers({tracks:"video",mimeType:n.mimeType})}},{key:"createSourceBuffers",value:function(n){var e=this.sourceBuffer,t=this.mediaSource,r=void 0,r=""===n.mimeType?"video/mp4;codecs=avc1.420028":"video/mp4;codecs="+n.mimeType;try{var a=e.video=t.addSourceBuffer(r);a.addEventListener("updateend",this.onsbue),track.buffer=a}catch(n){}this.wfs.trigger(o.default.BUFFER_CREATED,{tracks:n}),this.media.play(),this.media.addEventListener("pause",function(){this.play()},!0)}},{key:"doAppending",value:function(){var e=this.wfs,n=this.sourceBuffer,t=this.segments;if(Object.keys(n).length){if(this.media.error)return this.segments=[],void console.log("trying to append although a media error occured, flush segment and abort");if(!this.appending&&(t&&t.length)){var r=t.shift();try{n[r.type]&&!n[r.type].updating&&(this.parent=r.parent,n[r.type].appendBuffer(r.data),this.appendError=0,this.appending=!0,this.appended++)}catch(n){t.unshift(r);r={type:_errors.ErrorTypes.MEDIA_ERROR};if(22===n.code)return this.segments=[],void(r.details=ErrorDetails.BUFFER_FULL_ERROR);if(this.appendError?this.appendError++:this.appendError=1,r.details=ErrorDetails.BUFFER_APPEND_ERROR,r.frag=this.fragCurrent,this.appendError>e.config.appendErrorMaxRetry)return t=[],void(r.fatal=!0);r.fatal=!1}}}}}]),r=u;function u(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);n=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}(this,(u.__proto__||Object.getPrototypeOf(u)).call(this,n,o.default.MEDIA_ATTACHING,o.default.BUFFER_APPENDING,o.default.BUFFER_RESET));return n.mediaSource=null,n.media=null,n.pendingTracks={},n.sourceBuffer={},n.segments=[],n.appended=0,n._msDuration=null,n.preData=null,n.onsbue=n.onSBUpdateEnd.bind(n),n.browserType=0,-1!==navigator.userAgent.toLowerCase().indexOf("firefox")&&(n.browserType=1),n.mediaType="H264Raw",n.websocketUrl=void 0,n}t.default=r},{"../errors":7,"../event-handler":8,"../events":9}],4:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var o=s(n("../events")),i=s(n("../event-handler"));function s(n){return n&&n.__esModule?n:{default:n}}(function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)})(u,i.default),r(u,[{key:"destroy",value:function(){i.default.prototype.destroy.call(this)}},{key:"onMediaAttached",value:function(n){var e,t;null!=n.websocketUrl?(t=n.websocketUrl,e=n.connectId,t.indexOf("://")<0&&(t="ws://"+n.websocketUrl),(t=this.wfs.config[e].protocol?new WebSocket(t,this.wfs.config[e].protocol):new WebSocket(t)).id=e,this.wfs.attachWebsocket(t)):console.log("websocketUrl ERROE!!!")}},{key:"onBufferCreated",value:function(n){this.mediaType=n.mediaType}},{key:"onFileHeadLoaded",value:function(n){}},{key:"onFileDataLoaded",value:function(n){}},{key:"onFileParsingData",value:function(n){}},{key:"onWebsocketAttached",value:function(n){this.wfs.trigger(o.default.BUFFER_APPENDING,{type:"video",data:n.payload,parent:"main"})}},{key:"onFragParsingInitSegment",value:function(n){var e,t=n.tracks;for(e in(r=t.video)&&(r.id=n.id),t){var r,a=(r=t[e]).initSegment;a&&(this.pendingAppending++,this.wfs.trigger(o.default.BUFFER_APPENDING,{type:e,data:a,parent:"main"}))}}},{key:"onFragParsingData",value:function(e){var t=this;e.type,[e.data1,e.data2].forEach(function(n){n&&(t.pendingAppending++,t.wfs.trigger(o.default.BUFFER_APPENDING,{type:e.type,data:n,parent:"main"}))})}}]),r=u;function u(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);n=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}(this,(u.__proto__||Object.getPrototypeOf(u)).call(this,n,o.default.MEDIA_ATTACHED,o.default.BUFFER_CREATED,o.default.FILE_PARSING_DATA,o.default.FILE_HEAD_LOADED,o.default.FILE_DATA_LOADED,o.default.WEBSOCKET_ATTACHED,o.default.FRAG_PARSING_DATA,o.default.FRAG_PARSING_INIT_SEGMENT));return n.fileStart=0,n.fileEnd=0,n.pendingAppending=0,n.mediaType=void 0,n}t.default=r},{"../event-handler":8,"../events":9}],5:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var o=n("../utils/logger");r(i,[{key:"loadWord",value:function(){var n=this.data.byteLength-this.bytesAvailable,e=new Uint8Array(4),t=Math.min(4,this.bytesAvailable);if(0===t)throw new Error("no bytes available");e.set(this.data.subarray(n,n+t)),this.word=new DataView(e.buffer).getUint32(0),this.bitsAvailable=8*t,this.bytesAvailable-=t}},{key:"skipBits",value:function(n){var e;this.bitsAvailable>n||(n-=this.bitsAvailable,n-=(e=n>>3)>>3,this.bytesAvailable-=e,this.loadWord()),this.word<<=n,this.bitsAvailable-=n}},{key:"readBits",value:function(n){var e=Math.min(this.bitsAvailable,n),t=this.word>>>32-e;return 32<n&&o.logger.error("Cannot read more than 32 bits at a time"),this.bitsAvailable-=e,0<this.bitsAvailable?this.word<<=e:0<this.bytesAvailable&&this.loadWord(),0<(e=n-e)?t<<e|this.readBits(e):t}},{key:"skipLZ",value:function(){for(var n=0;n<this.bitsAvailable;++n)if(0!=(this.word&2147483648>>>n))return this.word<<=n,this.bitsAvailable-=n,n;return this.loadWord(),n+this.skipLZ()}},{key:"skipUEG",value:function(){this.skipBits(1+this.skipLZ())}},{key:"skipEG",value:function(){this.skipBits(1+this.skipLZ())}},{key:"readUEG",value:function(){var n=this.skipLZ();return this.readBits(n+1)-1}},{key:"readEG",value:function(){var n=this.readUEG();return 1&n?1+n>>>1:-1*(n>>>1)}},{key:"readBoolean",value:function(){return 1===this.readBits(1)}},{key:"readUByte",value:function(){return this.readBits(8)}},{key:"readUShort",value:function(){return this.readBits(16)}},{key:"readUInt",value:function(){return this.readBits(32)}},{key:"skipScalingList",value:function(n){for(var e=8,t=8,r=0;r<n;r++)e=0===(t=0!==t?(e+this.readEG()+256)%256:t)?e:t}},{key:"readSPS",value:function(){var n,e,t,r,a=0,o=0,i=0,s=0,u=1;if(this.readUByte(),e=this.readUByte(),this.readBits(5),this.skipBits(3),this.readUByte(),this.skipUEG(),100===e||110===e||122===e||244===e||44===e||83===e||86===e||118===e||128===e){var d=this.readUEG();if(3===d&&this.skipBits(1),this.skipUEG(),this.skipUEG(),this.skipBits(1),this.readBoolean())for(t=3!==d?8:12,r=0;r<t;r++)this.readBoolean()&&(r<6?this.skipScalingList(16):this.skipScalingList(64))}this.skipUEG();var l=this.readUEG();if(0===l)this.readUEG();else if(1===l)for(this.skipBits(1),this.skipEG(),this.skipEG(),n=this.readUEG(),r=0;r<n;r++)this.skipEG();if(this.skipUEG(),this.skipBits(1),e=this.readUEG(),d=this.readUEG(),0===(l=this.readBits(1))&&this.skipBits(1),this.skipBits(1),this.readBoolean()&&(a=this.readUEG(),o=this.readUEG(),i=this.readUEG(),s=this.readUEG()),this.readBoolean()&&this.readBoolean()){var f=void 0;switch(this.readUByte()){case 1:f=[1,1];break;case 2:f=[12,11];break;case 3:f=[10,11];break;case 4:f=[16,11];break;case 5:f=[40,33];break;case 6:f=[24,11];break;case 7:f=[20,11];break;case 8:f=[32,11];break;case 9:f=[80,33];break;case 10:f=[18,11];break;case 11:f=[15,11];break;case 12:f=[64,33];break;case 13:f=[160,99];break;case 14:f=[4,3];break;case 15:f=[3,2];break;case 16:f=[2,1];break;case 255:f=[this.readUByte()<<8|this.readUByte(),this.readUByte()<<8|this.readUByte()]}f&&(u=f[0]/f[1])}return{width:Math.ceil((16*(e+1)-2*a-2*o)*u),height:(2-l)*(d+1)*16-(l?2:4)*(i+s)}}},{key:"readSliceType",value:function(){return this.readUByte(),this.readUEG(),this.readUEG()}}]),r=i;function i(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,i),this.data=n,this.bytesAvailable=this.data.byteLength,this.word=0,this.bitsAvailable=0}t.default=r},{"../utils/logger":17}],6:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var h=s(n("../events")),m=s(n("./exp-golomb")),o=s(n("../event-handler")),i=s(n("../remux/mp4-remuxer"));function s(n){return n&&n.__esModule?n:{default:n}}(function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)})(u,o.default),r(u,[{key:"destroy",value:function(){o.default.prototype.destroy.call(this)}},{key:"getTimestampM",value:function(){return this.timestamp+=this.H264_TIMEBASE,this.timestamp}},{key:"onH264DataParsing",value:function(n){this._parseAVCTrack(n.data),this._avcTrack.samples.length&&this.remuxer.pushVideo(0,this.sn,this._avcTrack,this.timeOffset,this.contiguous),this.sn+=1}},{key:"onH265DataParsing",value:function(n){this.wfs.websocketLoader.worker.postMessage({cmd:n.cmd,data:n.data,frameType:n.frameType,id:n.id},[n.data.buffer])}},{key:"_parseAVCTrack",value:function(n){var e,o,i,s=this,u=this._avcTrack,t=u.samples,n=this._parseAVCNALu(n),d=[],l=!1,f=0,c="",p=function(){var n;d.length&&(!this.config.forceKeyFrameOnDiscontinuity||!0===l||u.sps&&(t.length||this.contiguous)?(n=this.getTimestampM(),e={units:{units:d,length:f},pts:n,dts:n,key:l},t.push(e),u.len+=f,u.nbNalu+=d.length):(deviceSdk.playStatus=!1,console.log("track.dropped",u.dropped),u.dropped++),d=[],f=0)}.bind(this);n.forEach(function(n){switch(n.type){case 1:o=!0;break;case 5:l=o=!0;break;case 6:n.data=s.discardEPB(n.data),new m.default(n.data).readUByte();break;case 7:if(o=!1,!u.sps){var e=new m.default(n.data).readSPS();u.width=e.width,u.height=e.height,u.sps=[n.data],u.duration=0;var t=n.data.subarray(1,4),r="avc1.";for(i=0;i<3;i++){var a=t[i].toString(16);r+=a=a.length<2?"0"+a:a}u.codec=r,s.wfs.trigger(h.default.BUFFER_RESET,{mimeType:u.codec}),o=!0}break;case 8:o=!1,u.pps||(u.pps=[n.data],o=!0);break;case 9:o=!1,p();break;default:o=!1,c+="unknown NAL "+n.type+" "}o&&(d.push(n),f+=n.data.byteLength)}),c.length&&logger.log(c),p()}},{key:"_parseAVCNALu",value:function(n){for(var e,t,r,a,o,i=0,s=n.byteLength,u=0,d=[];i<s;)switch(e=n[i++],u){case 0:0===e&&(u=1);break;case 1:u=0===e?2:0;break;case 2:case 3:u=0===e?3:(1===e&&i<s&&(r=31&n[i],a&&(t={data:n.subarray(a,i-u-1),type:o},d.push(t)),a=i,o=r),0)}return a&&(t={data:n.subarray(a,s),type:o,state:u},d.push(t)),d}},{key:"discardEPB",value:function(n){for(var e=n.byteLength,t=[],r=1;r<e-2;)0===n[r]&&0===n[r+1]&&3===n[r+2]?(t.push(r+2),r+=2):r++;if(0===t.length)return n;for(var a=e-t.length,o=new Uint8Array(a),i=0,r=0;r<a;i++,r++)i===t[0]&&(i++,t.shift()),o[r]=n[i];return o}}]),r=u;function u(n){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);var t=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}(this,(u.__proto__||Object.getPrototypeOf(u)).call(this,n,h.default.H264_DATA_PARSING,h.default.H265_DATA_PARSING));t.config=t.wfs.config||e,t.wfs=n,t.id="main";MediaSource.isTypeSupported("video/mp4");return t.remuxer=new i.default(t.wfs,t.id,t.config),t.contiguous=!0,t.timeOffset=1,t.sn=0,t.TIMESCALE=9e4,t.timestamp=0,t.scaleFactor=t.TIMESCALE/1e3,t.H264_TIMEBASE=3e3,t._avcTrack={container:"video/mp4",type:"video",id:1,sequenceNumber:0,samples:[],len:0,nbNalu:0,dropped:0,count:0},t.browserType=0,-1!==navigator.userAgent.toLowerCase().indexOf("firefox")&&(t.browserType=1),t}t.default=r},{"../errors":7,"../event-handler":8,"../events":9,"../remux/mp4-remuxer":16,"./exp-golomb":5}],7:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0})},{}],8:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},a=function(n,e,t){return e&&o(n.prototype,e),t&&o(n,t),n};function o(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var i,s=n("./events");(i=s)&&i.__esModule;a(u,[{key:"destroy",value:function(){this.unregisterListeners()}},{key:"isEventHandler",value:function(){return"object"===r(this.handledEvents)&&this.handledEvents.length&&"function"==typeof this.onEvent}},{key:"registerListeners",value:function(){this.isEventHandler()&&this.handledEvents.forEach(function(n){this.wfs.on(n,this.onEvent)}.bind(this))}},{key:"unregisterListeners",value:function(){this.isEventHandler()&&this.handledEvents.forEach(function(n){this.wfs.off(n,this.onEvent)}.bind(this))}},{key:"onEvent",value:function(n,e){this.onEventGeneric(n,e)}},{key:"onEventGeneric",value:function(e,n){try{!function(n,e){n="on"+n.replace("wfs","");return this[n],this[n].bind(this,e)}.call(this,e,n).call()}catch(n){console.log("internal error happened while processing "+e+":"+n.message)}}}]),a=u;function u(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u),this.wfs=n,this.onEvent=this.onEvent.bind(this);for(var e=arguments.length,t=Array(1<e?e-1:0),r=1;r<e;r++)t[r-1]=arguments[r];this.handledEvents=t,this.useGenericHandler=!0,this.registerListeners()}t.default=a},{"./events":9}],9:[function(n,e,t){e.exports={MEDIA_ATTACHING:"wfsMediaAttaching",MEDIA_ATTACHED:"wfsMediaAttached",FRAG_LOADING:"wfsFragLoading",BUFFER_CREATED:"wfsBufferCreated",BUFFER_APPENDING:"wfsBufferAppending",BUFFER_RESET:"wfsBufferReset",FRAG_PARSING_DATA:"wfsFragParsingData",FRAG_PARSING_INIT_SEGMENT:"wfsFragParsingInitSegment",H264_DATA_PARSING:"wfsH264DataParsing",H265_DATA_PARSING:"wfsH265DataParsing",WEBSOCKET_ATTACHED:"wfsWebsocketAttached",WEBSOCKET_ATTACHING:"wfsWebsocketAttaching",WEBSOCKET_DATA_UPLOADING:"wfsWebsocketDataUploading",WEBSOCKET_MESSAGE_SENDING:"wfsWebsocketMessageSending",FILE_HEAD_LOADING:"wfsFileHeadLoading",FILE_HEAD_LOADED:"wfsFileHeadLoaded",FILE_DATA_LOADING:"wfsFileDataLoading",FILE_DATA_LOADED:"wfsFileDataLoaded",FILE_PARSING_DATA:"wfsFileParsingData"}},{}],10:[function(n,e,t){function r(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}Object.defineProperty(t,"__esModule",{value:!0});var a=(function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}(o,null,[{key:"getSilentFrame",value:function(n){return 1===n?new Uint8Array([0,200,0,128,35,128]):2===n?new Uint8Array([33,0,73,144,2,25,0,35,128]):3===n?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]):4===n?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]):5===n?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]):6===n?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224]):null}}]),o);function o(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o)}t.default=a},{}],11:[function(n,e,t){e.exports=n("./wfs.js").default},{"./wfs.js":20}],12:[function(n,m,e){!function(c,p){var h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n};!function(){for(var n,e,t,r="object"===("undefined"==typeof window?"undefined":h(window))?window:{},a=!(r=!r.JS_CRC_NO_NODE_JS&&"object"===(void 0===c?"undefined":h(c))&&c.versions&&c.versions.node?p:r).JS_CRC_NO_COMMON_JS&&"object"===(void 0===m?"undefined":h(m))&&m.exports,u=!r.JS_CRC_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,d="0123456789abcdef".split(""),o=[{name:"crc32",polynom:3988292384,initValue:-1,bytes:4},{name:"crc16",polynom:40961,initValue:0,bytes:2}],i=0;i<o.length;++i)for((s=o[i]).method=function(e){return function(n){return l(n,e)}}(s),s.table=[],n=0;n<256;++n){for(t=n,e=0;e<8;++e)t=1&t?s.polynom^t>>>1:t>>>1;s.table[n]=t>>>0}var s,l=function(n,e){var t="string"!=typeof n;t&&u&&n instanceof ArrayBuffer&&(n=new Uint8Array(n));var r,a,o=e.initValue,i=n.length,s=e.table;if(t)for(a=0;a<i;++a)o=s[255&(o^n[a])]^o>>>8;else for(a=0;a<i;++a)o=(r=n.charCodeAt(a))<128?s[255&(o^r)]^o>>>8:r<2048?s[255&((o=s[255&(o^(192|r>>6))]^o>>>8)^(128|63&r))]^o>>>8:r<55296||57344<=r?s[255&((o=s[255&((o=s[255&(o^(224|r>>12))]^o>>>8)^(128|r>>6&63))]^o>>>8)^(128|63&r))]^o>>>8:s[255&((o=s[255&((o=s[255&((o=s[255&(o^(240|(r=65536+((1023&r)<<10|1023&n.charCodeAt(++a)))>>18))]^o>>>8)^(128|r>>12&63))]^o>>>8)^(128|r>>6&63))]^o>>>8)^(128|63&r))]^o>>>8;o^=e.initValue;t="";return 2<e.bytes&&(t+=d[o>>28&15]+d[o>>24&15]+d[o>>20&15]+d[o>>16&15]),t+=d[o>>12&15]+d[o>>8&15]+d[o>>4&15]+d[15&o]},f={};for(i=0;i<o.length;++i)f[(s=o[i]).name]=s.method;if(a)m.exports=f;else{for(i=0;i<o.length;++i)r[(s=o[i]).name]=s.method;0}}()}.call(this,n("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{_process:2}],13:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var o=s(n("../events")),i=s(n("../event-handler"));function s(n){return n&&n.__esModule?n:{default:n}}(function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)})(u,i.default),r(u,[{key:"destroy",value:function(){for(var n in this.loaders){n=this.loaders[n];n&&n.destroy()}this.loaders={},i.default.prototype.destroy.call(this)}},{key:"onFileHeadLoading",value:function(n){var e=this.wfs.config,t=new e.loader(e),r={url:e.fmp4FileUrl},a={maxRetry:0,retryDelay:0},o={onSuccess:this.fileloadheadsuccess.bind(this)};t.loadHead(r,a,o)}},{key:"fileloadheadsuccess",value:function(n){this.wfs.trigger(o.default.FILE_HEAD_LOADED,{size:n})}},{key:"onFileDataLoading",value:function(n){var e,t,r=this.wfs.config,a=new r.loader(r),o=void 0,o={url:r.fmp4FileUrl,responseType:"arraybuffer",progressData:!1},i=n.fileStart,n=n.fileEnd;isNaN(i)||isNaN(n)||(o.rangeStart=i,o.rangeEnd=n),e={timeout:r.fragLoadingTimeOut,maxRetry:0,retryDelay:0,maxRetryDelay:r.fragLoadingMaxRetryTimeout},t={onSuccess:this.fileloaddatasuccess.bind(this)},a.load(o,e,t)}},{key:"fileloaddatasuccess",value:function(n,e,t){this.wfs.trigger(o.default.FILE_DATA_LOADED,{payload:n.data,stats:e})}},{key:"loaderror",value:function(n,e){var t=e.loader;t&&t.abort(),this.loaders[e.type]=void 0}},{key:"loadtimeout",value:function(n,e){var t=e.loader;t&&t.abort(),this.loaders[e.type]=void 0}},{key:"loadprogress",value:function(n,e,t){e.frag.loaded=n.loaded}}]),r=u;function u(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);n=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}(this,(u.__proto__||Object.getPrototypeOf(u)).call(this,n,o.default.FRAG_LOADING,o.default.FILE_HEAD_LOADING,o.default.FILE_DATA_LOADING));return n.loaders={},n}t.default=r},{"../event-handler":8,"../events":9}],14:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var o=u(n("../events")),i=u(n("../event-handler")),s=u(n("../demux/h264-demuxer"));u(n("./crc.js"));function u(n){return n&&n.__esModule?n:{default:n}}(function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)})(d,i.default),r(d,[{key:"destroy",value:function(){i.default.prototype.destroy.call(this),this.client&&(this.bCloseManual=!0,this.client.onclose=function(){},this.client.close(),this.client=null)}},{key:"onWebsocketAttaching",value:function(n){if(this.mediaType=n.mediaType,null==n.initReqJson)return console.log("initReqJson error!");this.initReqJson=n.initReqJson;var e=n.websocket.id;n.websocket instanceof WebSocket&&(client.push(n.websocket),client[e].onopen=this.initSocketClient.bind(this),deviceSdk.wfs.config[e].audioStream=!1,client[e].onclose=function(n){deviceSdk.wfs&&deviceSdk.wfs.config[e]&&deviceSdk.wfs.config[e].onCallback("close"),console.log("Websocket Close!")})}},{key:"initSocketClient",value:function(n){n=n.currentTarget.id;client[n].binaryType="arraybuffer",client[n].onmessage=this.receiveSocketMessage.bind(this,n),this.wfs.trigger(o.default.WEBSOCKET_MESSAGE_SENDING,{req:this.initReqJson,id:n}),this.wfs.config[n].onCallback&&this.wfs.config[n].onCallback("open"),console.log("Websocket Open!")}},{key:"receiveSocketMessage",value:function(n,e){switch(this.wfs.config[n].type){case"BV":this.onSnDataReceive(e,n);break;case"IP":case"IPC":case"NVR":this.onIpDataReceive(e,n)}}},{key:"onWebsocketDataUploading",value:function(n){this.client.send(JSON.stringify(n.data))}},{key:"onWebsocketMessageSending",value:function(n){var e=n.id;3!=client[e].readyState&&2!=client[e].readyState&&client[e].send(JSON.stringify(n.req))}},{key:"getHeadMark",value:function(n){switch(this.wfs.config[n].type){case"BV":return{streamHead:305419896,streamType:273};case"IP":case"IPC":return{streamHead:1,streamType:36};default:return null}}},{key:"onSnDataReceive",value:function(n,e){var t=new DataView(n.data);if(this.playVideoReq){var r=t.getUint32(0,littleEndian)+8,a=t.getUint32(40,littleEndian),o=t.getUint32(4,littleEndian),i=(t.getUint32(28,littleEndian),t.getUint32(8,littleEndian),t.getUint32(12,littleEndian),t.getUint32(16,littleEndian)),s=t.getUint64(20,littleEndian),u=(t.getUint32(32,littleEndian),t.getUint32(36,littleEndian));this.buf=new Uint8Array(n.data);var d=this.buf.subarray(r,r+a+4);return r+a!=this.buf.byteLength?console.log("len error"):s<deviceSdk.dragTimeStamp?void 0:o==deviceSdk.streamIsAudio?this.audioPlayOfSn(u,d):this.videoPlayOfSn({encodeType:u,msTimeStamp:s,frameWidth:i,frameType:o},d,e)}i=t.getUint32(0,littleEndian),o=t.getUint32(4,littleEndian),d=this.getHeadMark(e);if(i!=d.streamHead||o!=d.streamType)return console.log("playVideoReq error");this.playVideoReq=!0,deviceSdk.nRelaySessionID=t.getUint32(12,littleEndian),deviceSdk.nRelaySockFd=t.getUint32(16,littleEndian),this.wfs.config[e].onCallback&&this.wfs.config[e].onCallback("playType")}},{key:"audioPlayOfSn",value:function(n,e){var t;switch(n){case 3:t=alawmulaw.mulaw.decode(e);break;case 4:t=alawmulaw.alaw.decode(e)}deviceSdk.audioSwitch&&this.audioPlayer.feed(t)}},{key:"videoPlayOfSn",value:function(n,e,t){var r={encodeType:n.encodeType,msTimeStamp:n.msTimeStamp,frameWidth:n.frameWidth};switch(this.wfs.config[t].onCallback&&this.wfs.config[t].onCallback("video",r),n.encodeType){case 0:case 1:case 7:"H264Raw"===this.mediaType&&this.wfs.trigger(o.default.H264_DATA_PARSING,{data:e});break;case 2:case 8:n.frameWidth<1921&&this.wfs.trigger(o.default.H265_DATA_PARSING,{cmd:"SN",data:e,frameType:n.frameType})}}},{key:"onIpDataReceive",value:function(n,e){this.nbMsg||(this.nbMsg=0),++this.nbMsg;var t=n.data;if(isJsonString(t)){n=JSON.parse(t);return"NVR"==this.wfs.config[e].type?this.wfs.config[e].onCallback("code",n):203==n.code||101==n.code?this.wfs.config[e].onCallback&&this.wfs.config[e].onCallback("pureCode",n.code):"IPC"==this.wfs.config[e].type&&0==n.data.stream?this.wfs.config[e].onCallback("stop",this.wfs):void 0}var r=new DataView(t),a=new Uint8Array(t.byteLength),o=r.getUint32(0,littleEndian),i=r.getUint32(32,littleEndian),s=this.getHeadMark(e);switch(this.buf=new Uint8Array(t),this.wfs.config[e].type){case"IP":this.ipcDataProcess(r,o,s,i,this.buf,a,e);break;case"NVR":this.nvrDataProcess(r,this.buf,a,e)}}},{key:"ipcDataProcess",value:function(n,e,t,r,a,o,i){if(e==t.streamHead&&r==t.streamType){var r=n.getUint8(4,littleEndian),t=n.getUint8(5,littleEndian),s=n.getUint32(28,littleEndian),u=new Uint8Array(a.subarray(36,o.length)),d=n.getUint32(12,littleEndian);if("IPC"==this.wfs.config[i].type&&(this.nbMsg%25==0&&this.wfs.config[i].onCallback&&this.wfs.config[i].onCallback("motionEn",1==t),3==s&&this.wfs.config[i].onCallback))return this.wfs.config[i].onCallback("mjpeg");switch(r){case 0:this.audioPlayOfIp(u,i);break;case 1:var l={nbMsg:this.nbMsg,encodingtype:s,mediaType:this.mediaType};this.wfs.config[i].onCallback&&this.wfs.config[i].onCallback("video",l),this.videoPlayOfIp(u,n,d,i)}}}},{key:"nvrDataProcess",value:function(n,e,t,r){var a=n.getUint8(4,littleEndian),o=(n.getUint8(5,littleEndian),n.getUint32(28,littleEndian)),i=new Uint8Array(e.subarray(36,t.length)),s=n.getUint32(12,littleEndian),e=n.getUint32(20,littleEndian),t=n.getUint32(24,littleEndian);switch(2==this.nbMsg&&(this.wfs.config[r].videoCode=this.mediaType,this.wfs.config[r].width=e,this.wfs.config[r].height=t,this.wfs.config[r].wsId=r),a){case 0:this.wfs.config[r].audioStream||(this.wfs.config[r].audioStream=!0),this.audioPlayOfIp(i,r,o);break;case 1:var u={nbMsg:this.nbMsg,encodingtype:o,mediaType:this.mediaType};this.wfs.config[r].onCallback&&this.wfs.config[r].onCallback("video",u,this.wfs.config[r]),this.videoPlayOfIp(i,n,s,r)}}},{key:"audioPlayOfIp",value:function(n,e,t){if(this.wfs.config[e].openSound)switch(t=t||this.wfs.config[e].aencType){case 1:case 2:case 16:case 17:var r="NVR"==this.wfs.config[e].type?2:17,r=((t||this.wfs.config[e].aencType)==r?alawmulaw.mulaw:alawmulaw.alaw).decode(n);this.audioPlayer.feed(r);break;case 21:var a=this;if(a.player)o=new Uint8Array(n),a.player.asset.source.append(o);else if(31<this.aacbuf.length){for(var o=new Uint8Array(a.aacbuf[0]),i=1;i<a.aacbuf.length;++i)o=this.appendByteArray(o,a.aacbuf[i]);a.player=AV.Player.fromBuffer(o),a.player.play(),this.aacbuf=[]}else this.aacbuf.push(n)}else this.player&&(this.player.stop(),this.player=null)}},{key:"appendByteArray",value:function(n,e){var t=new Uint8Array((0|n.byteLength)+(0|e.byteLength));return t.set(n,0),t.set(e,0|n.byteLength),t}},{key:"videoPlayOfIp",value:function(n,e,t,r){switch(this.wfs.config[r].onCallback&&(this.lastPbTime!=t&&this.wfs.config[r].onCallback("currPbTime",t),this.lastPbTime=t),this.mediaType){case"FMp4":this.wfs.trigger(o.default.WEBSOCKET_ATTACHED,{payload:n});break;case"H264Raw":this.wfs.trigger(o.default.H264_DATA_PARSING,{data:n}),7!=(31&e.getUint8(40,littleEndian))||this.lastSps||(this.lastSps=n),this.wfs.bRecording&&(this.wfs.recData||(this.wfs.recData=[this.lastSps]),this.wfs.recData.push(n));break;case"H265Raw":this.num265||(this.num265=0),++this.num265,this.wfs.trigger(o.default.H265_DATA_PARSING,{cmd:"IP",data:n,frameType:1,id:r})}}}]),r=d;function d(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,d);var e=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}(this,(d.__proto__||Object.getPrototypeOf(d)).call(this,n,o.default.WEBSOCKET_ATTACHING,o.default.WEBSOCKET_DATA_UPLOADING,o.default.WEBSOCKET_MESSAGE_SENDING));return e.buf=null,e.h264Demuxer=new s.default(n),e.mediaType=void 0,e.initReqJson=void 0,e.ratio=null,e.audioPlayer=new PCMPlayer({encoding:"16bitInt",channels:1,sampleRate:8e3,flushingTime:1e3}),e.aacbuf=[],e.worker=function(){try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){var n=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(n instanceof WebAssembly.Module)return new WebAssembly.Instance(n)instanceof WebAssembly.Instance}}catch(n){}return!1}()?new Worker(window.URL.createObjectURL(new Blob([libde265WorkerBlob],{type:"text/javascript"}))):new Worker(BLOBURL+"libde265-asm.js"),e.worker.onmessage=function(n){n=n.data;e.numDec265||(e.numDec265=0),++e.numDec265,e.togCost||(e.togCost=0),e.togCost+=Number(n.decCost),h265Conver[n.id]&&h265Conver[n.id].SR_DisplayFrameData(n.w,n.h,n.yuvData,h265Conver[n.id].capVideo,n.id)}.bind(this),e.startT=(new Date).getTime(),h265Conver.push(new SuperRender(n.canvasName)),e}t.default=r},{"../demux/h264-demuxer":6,"../event-handler":8,"../events":9,"./crc.js":12}],15:[function(n,e,t){function r(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}Object.defineProperty(t,"__esModule",{value:!0});var a=(function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}(l,null,[{key:"init",value:function(){for(var n in l.types={avc1:[],avcC:[],btrt:[],dinf:[],dref:[],esds:[],ftyp:[],hdlr:[],mdat:[],mdhd:[],mdia:[],mfhd:[],minf:[],moof:[],moov:[],mp4a:[],mvex:[],mvhd:[],sdtp:[],stbl:[],stco:[],stsc:[],stsd:[],stsz:[],stts:[],tfdt:[],tfhd:[],traf:[],trak:[],trun:[],trex:[],tkhd:[],vmhd:[],smhd:[]})l.types.hasOwnProperty(n)&&(l.types[n]=[n.charCodeAt(0),n.charCodeAt(1),n.charCodeAt(2),n.charCodeAt(3)]);var e=new Uint8Array([0,0,0,0,0,0,0,0,118,105,100,101,0,0,0,0,0,0,0,0,0,0,0,0,86,105,100,101,111,72,97,110,100,108,101,114,0]),t=new Uint8Array([0,0,0,0,0,0,0,0,115,111,117,110,0,0,0,0,0,0,0,0,0,0,0,0,83,111,117,110,100,72,97,110,100,108,101,114,0]);l.HDLR_TYPES={video:e,audio:t};var r=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,12,117,114,108,32,0,0,0,1]),a=new Uint8Array([0,0,0,0,0,0,0,0]);l.STTS=l.STSC=l.STCO=a,l.STSZ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0]),l.VMHD=new Uint8Array([0,0,0,1,0,0,0,0,0,0,0,0]),l.SMHD=new Uint8Array([0,0,0,0,0,0,0,0]),l.STSD=new Uint8Array([0,0,0,0,0,0,0,1]);e=new Uint8Array([105,115,111,109]),t=new Uint8Array([97,118,99,49]),a=new Uint8Array([0,0,0,1]);l.FTYP=l.box(l.types.ftyp,e,a,e,t),l.DINF=l.box(l.types.dinf,l.box(l.types.dref,r))}},{key:"box",value:function(n){for(var e,t=Array.prototype.slice.call(arguments,1),r=8,a=t.length,o=a;a--;)r+=t[a].byteLength;for((e=new Uint8Array(r))[0]=r>>24&255,e[1]=r>>16&255,e[2]=r>>8&255,e[3]=255&r,e.set(n,4),a=0,r=8;a<o;a++)e.set(t[a],r),r+=t[a].byteLength;return e}},{key:"hdlr",value:function(n){return l.box(l.types.hdlr,l.HDLR_TYPES[n])}},{key:"mdat",value:function(n){return l.box(l.types.mdat,n)}},{key:"mdhd",value:function(n,e){return l.box(l.types.mdhd,new Uint8Array([0,0,0,0,0,0,0,2,0,0,0,3,n>>24&255,n>>16&255,n>>8&255,255&n,0,0,0,0,85,196,0,0]))}},{key:"mdia",value:function(n){return l.box(l.types.mdia,l.mdhd(n.timescale,n.duration),l.hdlr(n.type),l.minf(n))}},{key:"mfhd",value:function(n){return l.box(l.types.mfhd,new Uint8Array([0,0,0,0,n>>24,n>>16&255,n>>8&255,255&n]))}},{key:"minf",value:function(n){return"audio"===n.type?l.box(l.types.minf,l.box(l.types.smhd,l.SMHD),l.DINF,l.stbl(n)):l.box(l.types.minf,l.box(l.types.vmhd,l.VMHD),l.DINF,l.stbl(n))}},{key:"moof",value:function(n,e,t){return l.box(l.types.moof,l.mfhd(n),l.traf(t,e))}},{key:"moov",value:function(n){for(var e=n.length,t=[];e--;)t[e]=l.trak(n[e]);return l.box.apply(null,[l.types.moov,l.mvhd(n[0].timescale,n[0].duration)].concat(t).concat(l.mvex(n)))}},{key:"mvex",value:function(n){for(var e=n.length,t=[];e--;)t[e]=l.trex(n[e]);return l.box.apply(null,[l.types.mvex].concat(t))}},{key:"mvhd",value:function(n,e){n=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,2,n>>24&255,n>>16&255,n>>8&255,255&n,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255]);return l.box(l.types.mvhd,n)}},{key:"sdtp",value:function(n){for(var e,t=n.samples||[],r=new Uint8Array(4+t.length),a=0;a<t.length;a++)e=t[a].flags,r[a+4]=e.dependsOn<<4|e.isDependedOn<<2|e.hasRedundancy;return l.box(l.types.sdtp,r)}},{key:"stbl",value:function(n){return l.box(l.types.stbl,l.stsd(n),l.box(l.types.stts,l.STTS),l.box(l.types.stsc,l.STSC),l.box(l.types.stsz,l.STSZ),l.box(l.types.stco,l.STCO))}},{key:"avc1",value:function(n){for(var e,t,r=[],a=[],o=0;o<n.sps.length;o++)t=(e=n.sps[o]).byteLength,r.push(t>>>8&255),r.push(255&t),r=r.concat(Array.prototype.slice.call(e));for(o=0;o<n.pps.length;o++)t=(e=n.pps[o]).byteLength,a.push(t>>>8&255),a.push(255&t),a=a.concat(Array.prototype.slice.call(e));var i=l.box(l.types.avcC,new Uint8Array([1,r[3],r[4],r[5],255,224|n.sps.length].concat(r).concat([n.pps.length]).concat(a))),s=n.width,u=n.height;return l.box(l.types.avc1,new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,s>>8&255,255&s,u>>8&255,255&u,0,72,0,0,0,72,0,0,0,0,0,0,0,1,18,106,101,102,102,45,121,97,110,47,47,47,103,119,102,115,46,106,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,17,17]),i,l.box(l.types.btrt,new Uint8Array([0,28,156,128,0,45,198,192,0,45,198,192])))}},{key:"esds",value:function(n){var e=n.config.length;return new Uint8Array([0,0,0,0,3,23+e,0,1,0,4,15+e,64,21,0,0,0,0,0,0,0,0,0,0,0,5].concat([e]).concat(n.config).concat([6,1,2]))}},{key:"mp4a",value:function(n){var e=n.audiosamplerate;return l.box(l.types.mp4a,new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,n.channelCount,0,16,0,0,0,0,e>>8&255,255&e,0,0]),l.box(l.types.esds,l.esds(n)))}},{key:"stsd",value:function(n){return"audio"===n.type?l.box(l.types.stsd,l.STSD,l.mp4a(n)):l.box(l.types.stsd,l.STSD,l.avc1(n))}},{key:"tkhd",value:function(n){var e=n.id,t=n.duration*n.timescale,r=n.width,n=n.height;return l.box(l.types.tkhd,new Uint8Array([0,0,0,7,0,0,0,0,0,0,0,0,e>>24&255,e>>16&255,e>>8&255,255&e,0,0,0,0,t>>24,t>>16&255,t>>8&255,255&t,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,r>>8&255,255&r,0,0,n>>8&255,255&n,0,0]))}},{key:"traf",value:function(n,e){var t=l.sdtp(n),r=n.id;return l.box(l.types.traf,l.box(l.types.tfhd,new Uint8Array([0,0,0,0,r>>24,r>>16&255,r>>8&255,255&r])),l.box(l.types.tfdt,new Uint8Array([0,0,0,0,e>>24,e>>16&255,e>>8&255,255&e])),l.trun(n,t.length+16+16+8+16+8+8),t)}},{key:"trak",value:function(n){return n.duration=n.duration||4294967295,l.box(l.types.trak,l.tkhd(n),l.mdia(n))}},{key:"trex",value:function(n){n=n.id;return l.box(l.types.trex,new Uint8Array([0,0,0,0,n>>24,n>>16&255,n>>8&255,255&n,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]))}},{key:"trun",value:function(n,e){var t,r,a,o,i,s=n.samples||[],u=s.length,n=12+16*u,d=new Uint8Array(n);for(d.set([0,0,15,1,u>>>24&255,u>>>16&255,u>>>8&255,255&u,(e+=8+n)>>>24&255,e>>>16&255,e>>>8&255,255&e],0),t=0;t<u;t++)r=(i=s[t]).duration,a=i.size,o=i.flags,i=i.cts,d.set([r>>>24&255,r>>>16&255,r>>>8&255,255&r,a>>>24&255,a>>>16&255,a>>>8&255,255&a,o.isLeading<<2|o.dependsOn,o.isDependedOn<<6|o.hasRedundancy<<4|o.paddingValue<<1|o.isNonSync,61440&o.degradPrio,15&o.degradPrio,i>>>24&255,i>>>16&255,i>>>8&255,255&i],12+16*t);return l.box(l.types.trun,d)}},{key:"initSegment",value:function(n){l.types||l.init();var e=l.moov(n),n=new Uint8Array(l.FTYP.byteLength+e.byteLength);return n.set(l.FTYP),n.set(e,l.FTYP.byteLength),n}}]),l);function l(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l)}t.default=a},{}],16:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var M=o(n("../helper/aac")),N=o(n("../events")),P=n("../utils/logger"),I=o(n("../remux/mp4-generator")),c=n("../errors");function o(n){return n&&n.__esModule?n:{default:n}}n("../utils/polyfill");r(i,[{key:"destroy",value:function(){}},{key:"insertDiscontinuity",value:function(){this._initPTS=this._initDTS=void 0}},{key:"switchLevel",value:function(){this.ISGenerated=!1}},{key:"pushVideo",value:function(n,e,t,r,a){this.level=n,this.sn=e;this.ISGenerated||this.generateVideoIS(t,r),this.ISGenerated&&t.samples.length&&this.remuxVideo_2(t,r,a)}},{key:"remuxVideo_2",value:function(n,e,t,r){var a=8,o=(this.PES_TIMESCALE,this.PES2MP4SCALEFACTOR,n.samples),i=[],s=new Uint8Array(n.len+4*n.nbNalu+8),u=new DataView(s.buffer);u.setUint32(0,s.byteLength),s.set(I.default.types.mdat,4);for(var d=0,l=void 0,f=void 0,c=void 0,p=0;p<o.length;p++){for(var h=o[p],m=0;h.units.units.length;){var _=h.units.units.shift();u.setUint32(a,_.data.byteLength),a+=4,s.set(_.data,a),a+=_.data.byteLength,m+=4+_.data.byteLength}var E,y=h.pts-this._initPTS,S=h.dts-this._initDTS;void 0!==c?(l=this._PTSNormalize(y,c),(d=(f=this._PTSNormalize(S,c))-c)<=0&&(P.logger.log("invalid sample duration at PTS/DTS: "+h.pts+"/"+h.dts+"|dts norm: "+f+"|lastDTS: "+c+":"+d),d=1)):(E=this.nextAvcDts,l=this._PTSNormalize(y,E),f=this._PTSNormalize(S,E),E&&(S=Math.round(f-E),Math.abs(S)<600&&S&&(1<S?P.logger.log("AVC:"+S+" ms hole between fragments detected,filling it"):S<-1&&P.logger.log("AVC:"+-S+" ms overlapping between fragments detected"),f=E,l=Math.max(l-S,f),P.logger.log("Video/PTS/DTS adjusted: "+l+"/"+f+",delta:"+S))),this.firstPTS=Math.max(0,l),this.firstDTS=Math.max(0,f),d=.03),i.push({size:m,duration:this.H264_TIMEBASE,cts:0,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:h.key?2:1,isNonSync:h.key?0:1}}),c=f}var v=0;2<=i.length&&(v=i[i.length-2].duration,i[0].duration=v),this.nextAvcDts=f+v;var g,v=n.dropped;n.len=0,n.nbNalu=0,n.dropped=0,i.length&&-1<navigator.userAgent.toLowerCase().indexOf("chrome")&&((g=i[0].flags).dependsOn=2,g.isNonSync=0),n.samples=i,g=I.default.moof(n.sequenceNumber++,f,n),n.samples=[];v={id:this.id,level:this.level,sn:this.sn,data1:g,data2:s,startPTS:l,endPTS:l,startDTS:f,endDTS:f,type:"video",nb:i.length,dropped:v};return this.observer.trigger(N.default.FRAG_PARSING_DATA,v),v}},{key:"generateVideoIS",value:function(n,e){var t,r,a=this.observer,o=n.samples,i=(this.PES_TIMESCALE,{}),s={id:this.id,level:this.level,sn:this.sn,tracks:i,unique:!1},u=void 0===this._initPTS;u&&(t=r=1/0),n.sps&&n.pps&&o.length&&(n.timescale=9e4,i.video={container:"video/mp4",codec:n.codec,initSegment:I.default.initSegment([n]),metadata:{width:n.width,height:n.height}},u&&(t=Math.min(t,o[0].pts-this.H264_TIMEBASE),r=Math.min(r,o[0].dts-this.H264_TIMEBASE))),Object.keys(i).length?(a.trigger(N.default.FRAG_PARSING_INIT_SEGMENT,s),this.ISGenerated=!0,u&&(this._initPTS=t,this._initDTS=r)):console.log("generateVideoIS ERROR==> ",c.ErrorTypes.MEDIA_ERROR)}},{key:"remux",value:function(n,e,t,r,a,o,i,s){var u;this.level=n,this.sn=e,this.ISGenerated||this.generateIS(t,r,i),this.ISGenerated&&(t.samples.length?(e=this.remuxAudio(t,i,s),r.samples.length&&(u=void 0,e&&(u=e.endPTS-e.startPTS),this.remuxVideo(r,i,s,u))):(u=void 0,(u=r.samples.length?this.remuxVideo(r,i,s):u)&&t.codec&&this.remuxEmptyAudio(t,i,s,u))),a.samples.length&&this.remuxID3(a,i),o.samples.length&&this.remuxText(o,i),this.observer.trigger(N.default.FRAG_PARSED,{id:this.id,level:this.level,sn:this.sn})}},{key:"generateIS",value:function(n,e,t){var r,a,o=this.observer,i=n.samples,s=e.samples,u=this.PES_TIMESCALE,d={},l={id:this.id,level:this.level,sn:this.sn,tracks:d,unique:!1},f=void 0===this._initPTS;f&&(r=a=1/0),n.config&&i.length&&(n.timescale=n.audiosamplerate,n.timescale*n.duration>Math.pow(2,32)&&(n.timescale=n.audiosamplerate/function n(e,t){return t?n(t,e%t):e}(n.audiosamplerate,1024)),P.logger.log("audio mp4 timescale :"+n.timescale),d.audio={container:"audio/mp4",codec:n.codec,initSegment:I.default.initSegment([n]),metadata:{channelCount:n.channelCount}},f&&(r=a=i[0].pts-u*t)),e.sps&&e.pps&&s.length&&(e.timescale=this.MP4_TIMESCALE,d.video={container:"video/mp4",codec:e.codec,initSegment:I.default.initSegment([e]),metadata:{width:e.width,height:e.height}},f&&(r=Math.min(r,s[0].pts-u*t),a=Math.min(a,s[0].dts-u*t))),Object.keys(d).length?(o.trigger(N.default.FRAG_PARSING_INIT_SEGMENT,l),this.ISGenerated=!0,f&&(this._initPTS=r,this._initDTS=a)):o.trigger(N.default.ERROR,{type:c.ErrorTypes.MEDIA_ERROR,id:this.id,details:ErrorDetails.FRAG_PARSING_ERROR,fatal:!1,reason:"no audio/video samples found"})}},{key:"remuxVideo",value:function(n,e,t,r){var a,o=8,i=this.PES_TIMESCALE,s=this.PES2MP4SCALEFACTOR,u=n.samples,d=[],l=void 0,l=t?this.nextAvcDts:e*i,f=u[0],c=Math.max(this._PTSNormalize(f.dts,l)-this._initDTS,0),p=Math.max(this._PTSNormalize(f.pts,l)-this._initDTS,0),h=Math.round((c-l)/90);t&&h&&(1<h?P.logger.log("AVC:"+h+" ms hole between fragments detected,filling it"):h<-1&&P.logger.log("AVC:"+-h+" ms overlapping between fragments detected"),u[0].dts=(c=l)+this._initDTS,p=Math.max(p-h,l),u[0].pts=p+this._initDTS,P.logger.log("Video/PTS/DTS adjusted: "+p+"/"+c+",delta:"+h)),f=u[u.length-1],e=Math.max(this._PTSNormalize(f.dts,l)-this._initDTS,0),t=Math.max(this._PTSNormalize(f.pts,l)-this._initDTS,0);var t=Math.max(t,e),h=navigator.vendor,f=navigator.userAgent,m=h&&-1<h.indexOf("Apple")&&f&&!f.match("CriOS");m&&(a=Math.round((e-c)/(s*(u.length-1))));for(var _=0;_<u.length;_++){var E=u[_];m?E.dts=c+_*s*a:(E.dts=Math.max(this._PTSNormalize(E.dts,l)-this._initDTS,c),E.dts=Math.round(E.dts/s)*s),E.pts=Math.max(this._PTSNormalize(E.pts,l)-this._initDTS,E.dts),E.pts=Math.round(E.pts/s)*s}var y=new Uint8Array(n.len+4*n.nbNalu+8),S=new DataView(y.buffer);S.setUint32(0,y.byteLength),y.set(I.default.types.mdat,4);for(var v=0;v<u.length;v++){for(var g,b,w,A=u[v],F=0,T=void 0;A.units.units.length;){var O=A.units.units.shift();S.setUint32(o,O.data.byteLength),o+=4,y.set(O.data,o),o+=O.data.byteLength,F+=4+O.data.byteLength}T=m?Math.max(0,a*Math.round((A.pts-A.dts)/(s*a))):(v<u.length-1?a=u[v+1].dts-A.dts:(w=this.config,g=A.dts-u[0<v?v-1:v].dts,w.stretchShortVideoTrack?(b=w.maxBufferHole,w=w.maxSeekHole,Math.floor(Math.min(b,w)*i)<(w=(r?p+r*i:this.nextAacPts)-A.pts)?((a=w-g)<0&&(a=g),P.logger.log("It is approximately "+w/90+" ms to the next segment; using duration "+a/90+" ms for the last video frame.")):a=g):a=g),a/=s,Math.round((A.pts-A.dts)/s)),d.push({size:F,duration:a,cts:T,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:A.key?2:1,isNonSync:A.key?0:1}})}this.nextAvcDts=e+a*s;var R,e=n.dropped;n.len=0,n.nbNalu=0,n.dropped=0,d.length&&-1<navigator.userAgent.toLowerCase().indexOf("chrome")&&((R=d[0].flags).dependsOn=2,R.isNonSync=0),n.samples=d,R=I.default.moof(n.sequenceNumber++,c/s,n),n.samples=[];e={id:this.id,level:this.level,sn:this.sn,data1:R,data2:y,startPTS:p/i,endPTS:(t+s*a)/i,startDTS:p/i,endDTS:(t+s*a)/i,type:"video",nb:d.length,dropped:e};return this.observer.trigger(N.default.FRAG_PARSING_DATA,e),e}},{key:"remuxAudio",value:function(n,e,t){var r,a,o,i,s,u,d,l=this.PES_TIMESCALE,f=l/n.timescale,c=1024*n.timescale/n.audiosamplerate,p=8,h=[],m=[];n.samples.sort(function(n,e){return n.pts-e.pts});for(var m=n.samples,_=t?this.nextAacPts:e*l,E=c*f,y=this._PTSNormalize(m[0].pts-this._initPTS,_)+E,S=1;S<m.length;){var v=m[S],g=this._PTSNormalize(v.pts-this._initPTS,_),b=g-y;if(b<-.5*E)P.logger.log("Dropping frame due to "+Math.abs(b/90)+" ms overlap."),m.splice(S,1),n.len-=v.unit.length;else if(.5*E<b){var w=Math.round(b/E);P.logger.log("Injecting "+w+" frame"+(1<w?"s":"")+" of missing audio due to "+Math.round(b/90)+" ms gap.");for(var A=0;A<w;A++){var F=m[S-1].pts+E,T=M.default.getSilentFrame(n.channelCount);T||(P.logger.log("Unable to get silent frame for given audio codec; duplicating last frame instead."),T=v.unit.slice(0)),m.splice(S,0,{unit:T,pts:F,dts:F}),n.len+=T.length,S+=1}y+=(w+1)*E,v.pts=m[S-1].pts+E,S+=1}else Math.abs(b)>.1*E&&P.logger.log("Invalid frame delta "+(g-y+E)+" at PTS "+Math.round(g/90)+" (should be "+E+")."),y+=E,v.pts=m[S-1].pts+E,S+=1}for(;m.length;){if(a=(D=m.shift()).unit,d=D.pts-this._initDTS,D=D.dts-this._initDTS,void 0!==u)O=this._PTSNormalize(d,u),R=this._PTSNormalize(D,u),r.duration=(R-u)/f;else{var O=this._PTSNormalize(d,_),R=this._PTSNormalize(D,_),D=Math.round(1e3*(O-_)/l);if(t&&D){if(0<D)P.logger.log(D+" ms hole between AAC samples detected,filling it");else if(D<-12){P.logger.log(-D+" ms overlapping between AAC samples detected, drop frame"),n.len-=a.byteLength;continue}O=R=_}if(i=Math.max(0,O),s=Math.max(0,R),!(0<n.len))return;o=new Uint8Array(n.len+8),new DataView(o.buffer).setUint32(0,o.byteLength),o.set(I.default.types.mdat,4)}o.set(a,p),p+=a.byteLength,r={size:a.byteLength,cts:0,duration:0,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:1}},h.push(r),u=R}var k=0,e=h.length;if(2<=e&&(k=h[e-2].duration,r.duration=k),e){this.nextAacPts=O+f*k,n.len=0,n.samples=h,c=I.default.moof(n.sequenceNumber++,s/f,n),n.samples=[];e={id:this.id,level:this.level,sn:this.sn,data1:c,data2:o,startPTS:i/l,endPTS:this.nextAacPts/l,startDTS:s/l,endDTS:(R+f*k)/l,type:"audio",nb:e};return this.observer.trigger(N.default.FRAG_PARSING_DATA,e),e}return null}},{key:"remuxEmptyAudio",value:function(n,e,t,r){var a=this.PES_TIMESCALE,o=n.timescale||n.audiosamplerate,i=r.startDTS*a+this._initDTS,r=r.endDTS*a+this._initDTS,s=1024*(a/o),u=Math.ceil((r-i)/s),d=M.default.getSilentFrame(n.channelCount);if(d){for(var l=[],f=0;f<u;f++){var c=i+f*s;l.push({unit:d.slice(0),pts:c,dts:c}),n.len+=d.length}n.samples=l,this.remuxAudio(n,e,t)}else P.logger.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!")}},{key:"remuxID3",value:function(n,e){var t,r=n.samples.length;if(r){for(var a=0;a<r;a++)(t=n.samples[a]).pts=(t.pts-this._initPTS)/this.PES_TIMESCALE,t.dts=(t.dts-this._initDTS)/this.PES_TIMESCALE;this.observer.trigger(N.default.FRAG_PARSING_METADATA,{id:this.id,level:this.level,sn:this.sn,samples:n.samples})}n.samples=[]}},{key:"remuxText",value:function(n,e){n.samples.sort(function(n,e){return n.pts-e.pts});var t,r=n.samples.length;if(r){for(var a=0;a<r;a++)(t=n.samples[a]).pts=(t.pts-this._initPTS)/this.PES_TIMESCALE;this.observer.trigger(N.default.FRAG_PARSING_USERDATA,{id:this.id,level:this.level,sn:this.sn,samples:n.samples})}n.samples=[]}},{key:"_PTSNormalize",value:function(n,e){var t;if(void 0===e)return n;for(t=e<n?-8589934592:8589934592;4294967296<Math.abs(n-e);)n+=t;return n}},{key:"passthrough",get:function(){return!1}}]),r=i;function i(n,e,t){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,i),this.observer=n,this.id=e,this.config=t,this.ISGenerated=!1,this.PES2MP4SCALEFACTOR=4,this.PES_TIMESCALE=9e4,this.MP4_TIMESCALE=this.PES_TIMESCALE/this.PES2MP4SCALEFACTOR,this.nextAvcDts=90300,this.H264_TIMEBASE=3e3}t.default=r},{"../errors":7,"../events":9,"../helper/aac":10,"../remux/mp4-generator":15,"../utils/logger":17,"../utils/polyfill":18}],17:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n};function a(){}var o={trace:a,debug:a,log:a,warn:a,info:a,error:a},i=o;function s(o){var i=window.console[o];return i?function(){for(var n,e,t=arguments.length,r=Array(t),a=0;a<t;a++)r[a]=arguments[a];r[0]&&(r[0]=(n=o,e=r[0],e="["+n+"] > "+e)),i.apply(window.console,r)}:a}t.enableLogs=function(n){if(!0===n||"object"===(void 0===n?"undefined":r(n))){!function(e){for(var n=arguments.length,t=Array(1<n?n-1:0),r=1;r<n;r++)t[r-1]=arguments[r];t.forEach(function(n){i[n]=e[n]?e[n].bind(e):s(n)})}(n,"debug","log","info","warn","error");try{i.log()}catch(n){i=o}}else i=o},t.logger=i},{}],18:[function(n,e,t){"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||(ArrayBuffer.prototype.slice=function(n,e){var t=new Uint8Array(this);void 0===e&&(e=t.length);for(var e=new ArrayBuffer(e-n),r=new Uint8Array(e),a=0;a<r.length;a++)r[a]=t[a+n];return e})},{}],19:[function(n,e,t){function r(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}Object.defineProperty(t,"__esModule",{value:!0});var a=(function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}(o,[{key:"destroy",value:function(){this.abort(),this.loader=null}},{key:"abort",value:function(){var n=this.loader;n&&4!==n.readyState&&(this.stats.aborted=!0,n.abort()),window.clearTimeout(this.requestTimeout),this.requestTimeout=null,window.clearTimeout(this.retryTimeout),this.retryTimeout=null}},{key:"loadHead",value:function(n,e,t){this.context=n,this.config=e,this.callbacks=t,this.stats={trequest:performance.now(),retry:0},this.retryDelay=e.retryDelay;var r=new XMLHttpRequest;r.open("head",n.url),r.onload=function(){t.onSuccess(r.getResponseHeader("content-length"))},r.send()}},{key:"load",value:function(n,e,t){this.context=n,this.config=e,this.callbacks=t,this.stats={trequest:performance.now(),retry:0},this.retryDelay=e.retryDelay,this.loadInternal()}},{key:"loadInternal",value:function(){var n=this.context,e="undefined"!=typeof XDomainRequest?this.loader=new XDomainRequest:this.loader=new XMLHttpRequest;e.onloadend=this.loadend.bind(this),e.onprogress=this.loadprogress.bind(this),e.open("GET",n.url,!0),n.rangeEnd&&e.setRequestHeader("Range","bytes="+n.rangeStart+"-"+(n.rangeEnd-1)),e.responseType=n.responseType;var t=this.stats;t.tfirst=0,t.loaded=0,this.xhrSetup&&this.xhrSetup(e,n.url),this.requestTimeout=window.setTimeout(this.loadtimeout.bind(this),this.config.timeout),e.send()}},{key:"loadend",value:function(n){var e,t=n.currentTarget,r=t.status,a=this.stats,o=this.context,i=this.config;a.aborted||(window.clearTimeout(this.requestTimeout),200<=r&&r<300?(a.tload=Math.max(a.tfirst,performance.now()),n=e=void 0,n="arraybuffer"===o.responseType?(e=t.response).byteLength:(e=t.responseText).length,a.loaded=a.total=n,e={url:t.responseURL,data:e},this.callbacks.onSuccess(e,a,o)):a.retry>=i.maxRetry||400<=r&&r<499?this.callbacks.onError({code:r,text:t.statusText},o):(this.destroy(),this.retryTimeout=window.setTimeout(this.loadInternal.bind(this),this.retryDelay),this.retryDelay=Math.min(2*this.retryDelay,i.maxRetryDelay),a.retry++))}},{key:"loadtimeout",value:function(){this.callbacks.onTimeout(this.stats,this.context)}},{key:"loadprogress",value:function(n){var e=this.stats;0===e.tfirst&&(e.tfirst=Math.max(performance.now(),e.trequest)),e.loaded=n.loaded,n.lengthComputable&&(e.total=n.total);n=this.callbacks.onProgress;n&&n(e,this.context,null)}}]),o);function o(n){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),n&&n.xhrSetup&&(this.xhrSetup=n.xhrSetup)}t.default=a},{}],20:[function(n,e,t){Object.defineProperty(t,"__esModule",{value:!0});var r=function(n,e,t){return e&&a(n.prototype,e),t&&a(n,t),n};function a(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var o=f(n("./events")),i=f(n("./controller/flow-controller")),s=f(n("./controller/buffer-controller")),u=f(n("events")),d=f(n("./utils/xhr-loader")),l=(f(n("./loader/file-loader")),f(n("./loader/websocket-loader")));function f(n){return n&&n.__esModule?n:{default:n}}r(c,null,[{key:"isSupported",value:function(){return window.MediaSource&&"function"==typeof window.MediaSource.isTypeSupported&&window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42c01f,mp4a.40.2"')}},{key:"version",get:function(){return"v.0.0.0.1"}},{key:"Events",get:function(){return o.default}},{key:"DefaultConfig",get:function(){return c.defaultConfig=!c.defaultConfig?{autoStartLoad:!0,startPosition:-1,debug:!1,fLoader:void 0,loader:d.default,fmp4FileUrl:"xxxx.mp4",fragLoadingTimeOut:2e4,fragLoadingMaxRetry:6,fragLoadingRetryDelay:1e3,fragLoadingMaxRetryTimeout:64e3,fragLoadingLoopThreshold:3,forceKeyFrameOnDiscontinuity:!0,appendErrorMaxRetry:3}:c.defaultConfig},set:function(n){c.defaultConfig=n}}]),r(c,[{key:"destroy",value:function(n){if(this.flowController.destroy(),this.bufferController.destroy(),this.websocketLoader.destroy(),this.media){switch(this.mediaType){case"H264Raw":this.media.pause(),this.media.removeAttribute("src"),this.media.load();break;case"H265Raw":if(!this.websocketLoader.worker)return;if(!h265Conver[n]||!h265Conver[n].contextGL)return;h265Conver[n].SR_Destroy(),h265Conver[n]=void 0}this.audioPlayer&&this.audioPlayer.audioCtx&&this.audioPlayer.destroy()}}},{key:"attachMedia",value:function(n,e,t,r,a){this.mediaType=r||"H264Raw",this.media=n,this.initReqJson=t,this.trigger(o.default.MEDIA_ATTACHING,{media:n,mediaType:this.mediaType,websocketUrl:e,id:a})}},{key:"attachWebsocket",value:function(n){this.trigger(o.default.WEBSOCKET_ATTACHING,{websocket:n,mediaType:this.mediaType,initReqJson:this.initReqJson})}},{key:"setConfig",value:function(n,e,t){return this.config[t][n]=e,this.config}},{key:"sendWebsocketData",value:function(n){var e;"H264Raw"==this.mediaType&&"setSpeed"==n.action&&(e=0<(e=parseInt(n.data.speed))?Math.pow(2,e):1/Math.pow(2,Math.abs(e)),this.media.playbackRate=e),this.trigger(o.default.WEBSOCKET_DATA_UPLOADING,{data:n})}},{key:"stopWebsocket",value:function(n){if(client[n]){if(client[n].close(),"NVR"!=deviceSdk.wfs.config[n].type)return this.initWebsocketData();delete client[n],delete h265Conver[n],delete configInfo[n]}}},{key:"sendMessage",value:function(n,e){client[n]&&client[n].send(JSON.stringify(e))}},{key:"initWebsocketData",value:function(){client=[],h265Conver=[],configInfo=[]}},{key:"getConfigInfo",value:function(){return this.config}},{key:"initConfigInfo",value:function(){this.config=[]}},{key:"setH265Conver",value:function(n,e,t){h265Conver[n][e]=t}},{key:"getH265Conver",value:function(n){return h265Conver[n]}}]),r=c;function c(){var n,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=c.DefaultConfig;for(n in this.config||(this.config=[]),t)n in e||(e[n]=t[n]);configInfo.push(e),this.config=configInfo,this.canvasName=arguments[1];var a=this.observer=new u.default;a.trigger=function(n){for(var e=arguments.length,t=Array(1<e?e-1:0),r=1;r<e;r++)t[r-1]=arguments[r];a.emit.apply(a,[n,n].concat(t))},a.off=function(n){for(var e=arguments.length,t=Array(1<e?e-1:0),r=1;r<e;r++)t[r-1]=arguments[r];a.removeListener.apply(a,[n].concat(t))},this.on=a.on.bind(a),this.off=a.off.bind(a),this.trigger=a.trigger.bind(a),this.flowController=new i.default(this),this.bufferController=new s.default(this),this.websocketLoader=new l.default(this),this.mediaType=void 0}t.default=r},{"./controller/buffer-controller":3,"./controller/flow-controller":4,"./events":9,"./loader/file-loader":13,"./loader/websocket-loader":14,"./utils/xhr-loader":19,events:1}]},{},[11])(11)}),DataView.prototype.getUint64=function(n,e){var t=this.getUint32(n,e),n=this.getUint32(n+4,e),n=e?t+Math.pow(2,32)*n:Math.pow(2,32)*t+n;return Number.isSafeInteger(n)||console.warn(n,"exceeds MAX_SAFE_INTEGER. Precision may be lost"),n};